
Atmega640_RTOSa.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000e  00800200  0000154c  000015e0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001546  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .isr          00000006  00001546  00001546  000015da  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .bss          0000085d  0080020e  0080020e  000015ee  2**0
                  ALLOC
  4 .comment      00000030  00000000  00000000  000015ee  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000248  00000000  00000000  0000161e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000016b6  00000000  00000000  00001866  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000594  00000000  00000000  00002f1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000cf1  00000000  00000000  000034b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000007c0  00000000  00000000  000041a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000c49  00000000  00000000  00004964  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000f61  00000000  00000000  000055ad  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000200  00000000  00000000  0000650e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
       4:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
       8:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
       c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      10:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      14:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      18:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      1c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      20:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      24:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      28:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      2c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      30:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      34:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      38:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      3c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      40:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      44:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      48:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      4c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      50:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      54:	0c 94 a3 0a 	jmp	0x1546	; 0x1546 <_etext>
      58:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      5c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      60:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      64:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      68:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      6c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      70:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      74:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      78:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      7c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      80:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      84:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      88:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      8c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      90:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      94:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      98:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      9c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      a0:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      a4:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      a8:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      ac:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      b0:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      b4:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      b8:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      bc:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      c0:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      c4:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      c8:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      cc:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      d0:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      d4:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      d8:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      dc:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      e0:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61

000000f0 <__do_copy_data>:
      f0:	12 e0       	ldi	r17, 0x02	; 2
      f2:	a0 e0       	ldi	r26, 0x00	; 0
      f4:	b2 e0       	ldi	r27, 0x02	; 2
      f6:	ec e4       	ldi	r30, 0x4C	; 76
      f8:	f5 e1       	ldi	r31, 0x15	; 21
      fa:	02 c0       	rjmp	.+4      	; 0x100 <__do_copy_data+0x10>
      fc:	05 90       	lpm	r0, Z+
      fe:	0d 92       	st	X+, r0
     100:	ae 30       	cpi	r26, 0x0E	; 14
     102:	b1 07       	cpc	r27, r17
     104:	d9 f7       	brne	.-10     	; 0xfc <__do_copy_data+0xc>

00000106 <__do_clear_bss>:
     106:	2a e0       	ldi	r18, 0x0A	; 10
     108:	ae e0       	ldi	r26, 0x0E	; 14
     10a:	b2 e0       	ldi	r27, 0x02	; 2
     10c:	01 c0       	rjmp	.+2      	; 0x110 <.do_clear_bss_start>

0000010e <.do_clear_bss_loop>:
     10e:	1d 92       	st	X+, r1

00000110 <.do_clear_bss_start>:
     110:	ab 36       	cpi	r26, 0x6B	; 107
     112:	b2 07       	cpc	r27, r18
     114:	e1 f7       	brne	.-8      	; 0x10e <.do_clear_bss_loop>
     116:	0e 94 91 00 	call	0x122	; 0x122 <main>
     11a:	0c 94 a1 0a 	jmp	0x1542	; 0x1542 <_exit>

0000011e <__bad_interrupt>:
     11e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000122 <main>:
void vApplicationIdleHook( void );

/*-----------------------------------------------------------*/

int main( void )
{
     122:	cf 93       	push	r28
     124:	df 93       	push	r29
     126:	cd b7       	in	r28, 0x3d	; 61
     128:	de b7       	in	r29, 0x3e	; 62
	prvIncrementResetCount();
     12a:	0e 94 a0 00 	call	0x140	; 0x140 <prvIncrementResetCount>
	
	// Perform Blinker setup
	blinkerSetup();
     12e:	0e 94 ae 00 	call	0x15c	; 0x15c <blinkerSetup>
	
	/* In this port, to use preemptive scheduler define configUSE_PREEMPTION
	as 1 in portmacro.h.  To use the cooperative scheduler define
	configUSE_PREEMPTION as 0. */
	vTaskStartScheduler();
     132:	0e 94 8f 06 	call	0xd1e	; 0xd1e <vTaskStartScheduler>
	
	return 0;
     136:	80 e0       	ldi	r24, 0x00	; 0
     138:	90 e0       	ldi	r25, 0x00	; 0
}
     13a:	df 91       	pop	r29
     13c:	cf 91       	pop	r28
     13e:	08 95       	ret

00000140 <prvIncrementResetCount>:
/*-----------------------------------------------------------*/

static void prvIncrementResetCount( void )
{
     140:	cf 93       	push	r28
     142:	df 93       	push	r29
     144:	cd b7       	in	r28, 0x3d	; 61
     146:	de b7       	in	r29, 0x3e	; 62
//unsigned char ucCount;
//
	//eeprom_read_block( &ucCount, mainRESET_COUNT_ADDRESS, sizeof( ucCount ) );
	//ucCount++;
	//eeprom_write_byte( mainRESET_COUNT_ADDRESS, ucCount );
}
     148:	df 91       	pop	r29
     14a:	cf 91       	pop	r28
     14c:	08 95       	ret

0000014e <vApplicationIdleHook>:
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
     14e:	cf 93       	push	r28
     150:	df 93       	push	r29
     152:	cd b7       	in	r28, 0x3d	; 61
     154:	de b7       	in	r29, 0x3e	; 62
	//vCoRoutineSchedule();
     156:	df 91       	pop	r29
     158:	cf 91       	pop	r28
     15a:	08 95       	ret

0000015c <blinkerSetup>:
// Task function Prototype
void vBlinker( void );

//////////////////////////////////////////////////////////////////////////
//	Blinker Setup Function
void blinkerSetup( void ) {
     15c:	af 92       	push	r10
     15e:	bf 92       	push	r11
     160:	cf 92       	push	r12
     162:	df 92       	push	r13
     164:	ef 92       	push	r14
     166:	ff 92       	push	r15
     168:	0f 93       	push	r16
     16a:	cf 93       	push	r28
     16c:	df 93       	push	r29
     16e:	cd b7       	in	r28, 0x3d	; 61
     170:	de b7       	in	r29, 0x3e	; 62
	// Set the pin as defined in the header file
	blinkerPORT_DDR |= (1 << blinkerPIN);
     172:	8a e0       	ldi	r24, 0x0A	; 10
     174:	91 e0       	ldi	r25, 0x01	; 1
     176:	2a e0       	ldi	r18, 0x0A	; 10
     178:	31 e0       	ldi	r19, 0x01	; 1
     17a:	f9 01       	movw	r30, r18
     17c:	20 81       	ld	r18, Z
     17e:	20 68       	ori	r18, 0x80	; 128
     180:	fc 01       	movw	r30, r24
     182:	20 83       	st	Z, r18
	
	// Initialize the pin with the ON value
	blinkerPORT |= (1 << blinkerPIN);
     184:	8b e0       	ldi	r24, 0x0B	; 11
     186:	91 e0       	ldi	r25, 0x01	; 1
     188:	2b e0       	ldi	r18, 0x0B	; 11
     18a:	31 e0       	ldi	r19, 0x01	; 1
     18c:	f9 01       	movw	r30, r18
     18e:	20 81       	ld	r18, Z
     190:	20 68       	ori	r18, 0x80	; 128
     192:	fc 01       	movw	r30, r24
     194:	20 83       	st	Z, r18
	
	// Create the Task to be started after scheduler is asked to run
	xTaskCreate( vBlinker, "Blin", configMINIMAL_STACK_SIZE*2, NULL, 2, NULL );
     196:	a1 2c       	mov	r10, r1
     198:	b1 2c       	mov	r11, r1
     19a:	c1 2c       	mov	r12, r1
     19c:	d1 2c       	mov	r13, r1
     19e:	e1 2c       	mov	r14, r1
     1a0:	f1 2c       	mov	r15, r1
     1a2:	02 e0       	ldi	r16, 0x02	; 2
     1a4:	20 e0       	ldi	r18, 0x00	; 0
     1a6:	30 e0       	ldi	r19, 0x00	; 0
     1a8:	4a ea       	ldi	r20, 0xAA	; 170
     1aa:	50 e0       	ldi	r21, 0x00	; 0
     1ac:	64 e0       	ldi	r22, 0x04	; 4
     1ae:	72 e0       	ldi	r23, 0x02	; 2
     1b0:	86 ee       	ldi	r24, 0xE6	; 230
     1b2:	90 e0       	ldi	r25, 0x00	; 0
     1b4:	0e 94 74 05 	call	0xae8	; 0xae8 <xTaskGenericCreate>
	
}
     1b8:	df 91       	pop	r29
     1ba:	cf 91       	pop	r28
     1bc:	0f 91       	pop	r16
     1be:	ff 90       	pop	r15
     1c0:	ef 90       	pop	r14
     1c2:	df 90       	pop	r13
     1c4:	cf 90       	pop	r12
     1c6:	bf 90       	pop	r11
     1c8:	af 90       	pop	r10
     1ca:	08 95       	ret

000001cc <vBlinker>:

void vBlinker( void ) {
     1cc:	cf 93       	push	r28
     1ce:	df 93       	push	r29
     1d0:	cd b7       	in	r28, 0x3d	; 61
     1d2:	de b7       	in	r29, 0x3e	; 62
	
	
	// Simply blink forever
	for (;;)
	{
		vTaskDelay( ( TickType_t ) blinkerRate );
     1d4:	80 91 00 02 	lds	r24, 0x0200
     1d8:	90 91 01 02 	lds	r25, 0x0201
     1dc:	0e 94 5a 06 	call	0xcb4	; 0xcb4 <vTaskDelay>
		blinkerPORT ^= (1 << blinkerPIN);
     1e0:	8b e0       	ldi	r24, 0x0B	; 11
     1e2:	91 e0       	ldi	r25, 0x01	; 1
     1e4:	2b e0       	ldi	r18, 0x0B	; 11
     1e6:	31 e0       	ldi	r19, 0x01	; 1
     1e8:	f9 01       	movw	r30, r18
     1ea:	30 81       	ld	r19, Z
     1ec:	20 e8       	ldi	r18, 0x80	; 128
     1ee:	23 27       	eor	r18, r19
     1f0:	fc 01       	movw	r30, r24
     1f2:	20 83       	st	Z, r18
		
	}
     1f4:	ef cf       	rjmp	.-34     	; 0x1d4 <vBlinker+0x8>

000001f6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     1f6:	cf 93       	push	r28
     1f8:	df 93       	push	r29
     1fa:	00 d0       	rcall	.+0      	; 0x1fc <vListInitialise+0x6>
     1fc:	cd b7       	in	r28, 0x3d	; 61
     1fe:	de b7       	in	r29, 0x3e	; 62
     200:	9a 83       	std	Y+2, r25	; 0x02
     202:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     204:	89 81       	ldd	r24, Y+1	; 0x01
     206:	9a 81       	ldd	r25, Y+2	; 0x02
     208:	9c 01       	movw	r18, r24
     20a:	2d 5f       	subi	r18, 0xFD	; 253
     20c:	3f 4f       	sbci	r19, 0xFF	; 255
     20e:	89 81       	ldd	r24, Y+1	; 0x01
     210:	9a 81       	ldd	r25, Y+2	; 0x02
     212:	fc 01       	movw	r30, r24
     214:	32 83       	std	Z+2, r19	; 0x02
     216:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     218:	89 81       	ldd	r24, Y+1	; 0x01
     21a:	9a 81       	ldd	r25, Y+2	; 0x02
     21c:	2f ef       	ldi	r18, 0xFF	; 255
     21e:	3f ef       	ldi	r19, 0xFF	; 255
     220:	fc 01       	movw	r30, r24
     222:	34 83       	std	Z+4, r19	; 0x04
     224:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     226:	89 81       	ldd	r24, Y+1	; 0x01
     228:	9a 81       	ldd	r25, Y+2	; 0x02
     22a:	9c 01       	movw	r18, r24
     22c:	2d 5f       	subi	r18, 0xFD	; 253
     22e:	3f 4f       	sbci	r19, 0xFF	; 255
     230:	89 81       	ldd	r24, Y+1	; 0x01
     232:	9a 81       	ldd	r25, Y+2	; 0x02
     234:	fc 01       	movw	r30, r24
     236:	36 83       	std	Z+6, r19	; 0x06
     238:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     23a:	89 81       	ldd	r24, Y+1	; 0x01
     23c:	9a 81       	ldd	r25, Y+2	; 0x02
     23e:	9c 01       	movw	r18, r24
     240:	2d 5f       	subi	r18, 0xFD	; 253
     242:	3f 4f       	sbci	r19, 0xFF	; 255
     244:	89 81       	ldd	r24, Y+1	; 0x01
     246:	9a 81       	ldd	r25, Y+2	; 0x02
     248:	fc 01       	movw	r30, r24
     24a:	30 87       	std	Z+8, r19	; 0x08
     24c:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     24e:	89 81       	ldd	r24, Y+1	; 0x01
     250:	9a 81       	ldd	r25, Y+2	; 0x02
     252:	fc 01       	movw	r30, r24
     254:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     256:	0f 90       	pop	r0
     258:	0f 90       	pop	r0
     25a:	df 91       	pop	r29
     25c:	cf 91       	pop	r28
     25e:	08 95       	ret

00000260 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     260:	cf 93       	push	r28
     262:	df 93       	push	r29
     264:	00 d0       	rcall	.+0      	; 0x266 <vListInitialiseItem+0x6>
     266:	cd b7       	in	r28, 0x3d	; 61
     268:	de b7       	in	r29, 0x3e	; 62
     26a:	9a 83       	std	Y+2, r25	; 0x02
     26c:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     26e:	89 81       	ldd	r24, Y+1	; 0x01
     270:	9a 81       	ldd	r25, Y+2	; 0x02
     272:	fc 01       	movw	r30, r24
     274:	11 86       	std	Z+9, r1	; 0x09
     276:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     278:	0f 90       	pop	r0
     27a:	0f 90       	pop	r0
     27c:	df 91       	pop	r29
     27e:	cf 91       	pop	r28
     280:	08 95       	ret

00000282 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     282:	cf 93       	push	r28
     284:	df 93       	push	r29
     286:	00 d0       	rcall	.+0      	; 0x288 <vListInsertEnd+0x6>
     288:	00 d0       	rcall	.+0      	; 0x28a <vListInsertEnd+0x8>
     28a:	00 d0       	rcall	.+0      	; 0x28c <vListInsertEnd+0xa>
     28c:	cd b7       	in	r28, 0x3d	; 61
     28e:	de b7       	in	r29, 0x3e	; 62
     290:	9c 83       	std	Y+4, r25	; 0x04
     292:	8b 83       	std	Y+3, r24	; 0x03
     294:	7e 83       	std	Y+6, r23	; 0x06
     296:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
     298:	8b 81       	ldd	r24, Y+3	; 0x03
     29a:	9c 81       	ldd	r25, Y+4	; 0x04
     29c:	fc 01       	movw	r30, r24
     29e:	81 81       	ldd	r24, Z+1	; 0x01
     2a0:	92 81       	ldd	r25, Z+2	; 0x02
     2a2:	9a 83       	std	Y+2, r25	; 0x02
     2a4:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     2a6:	8d 81       	ldd	r24, Y+5	; 0x05
     2a8:	9e 81       	ldd	r25, Y+6	; 0x06
     2aa:	29 81       	ldd	r18, Y+1	; 0x01
     2ac:	3a 81       	ldd	r19, Y+2	; 0x02
     2ae:	fc 01       	movw	r30, r24
     2b0:	33 83       	std	Z+3, r19	; 0x03
     2b2:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     2b4:	89 81       	ldd	r24, Y+1	; 0x01
     2b6:	9a 81       	ldd	r25, Y+2	; 0x02
     2b8:	fc 01       	movw	r30, r24
     2ba:	24 81       	ldd	r18, Z+4	; 0x04
     2bc:	35 81       	ldd	r19, Z+5	; 0x05
     2be:	8d 81       	ldd	r24, Y+5	; 0x05
     2c0:	9e 81       	ldd	r25, Y+6	; 0x06
     2c2:	fc 01       	movw	r30, r24
     2c4:	35 83       	std	Z+5, r19	; 0x05
     2c6:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     2c8:	89 81       	ldd	r24, Y+1	; 0x01
     2ca:	9a 81       	ldd	r25, Y+2	; 0x02
     2cc:	fc 01       	movw	r30, r24
     2ce:	84 81       	ldd	r24, Z+4	; 0x04
     2d0:	95 81       	ldd	r25, Z+5	; 0x05
     2d2:	2d 81       	ldd	r18, Y+5	; 0x05
     2d4:	3e 81       	ldd	r19, Y+6	; 0x06
     2d6:	fc 01       	movw	r30, r24
     2d8:	33 83       	std	Z+3, r19	; 0x03
     2da:	22 83       	std	Z+2, r18	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	9a 81       	ldd	r25, Y+2	; 0x02
     2e0:	2d 81       	ldd	r18, Y+5	; 0x05
     2e2:	3e 81       	ldd	r19, Y+6	; 0x06
     2e4:	fc 01       	movw	r30, r24
     2e6:	35 83       	std	Z+5, r19	; 0x05
     2e8:	24 83       	std	Z+4, r18	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     2ea:	8d 81       	ldd	r24, Y+5	; 0x05
     2ec:	9e 81       	ldd	r25, Y+6	; 0x06
     2ee:	2b 81       	ldd	r18, Y+3	; 0x03
     2f0:	3c 81       	ldd	r19, Y+4	; 0x04
     2f2:	fc 01       	movw	r30, r24
     2f4:	31 87       	std	Z+9, r19	; 0x09
     2f6:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     2f8:	8b 81       	ldd	r24, Y+3	; 0x03
     2fa:	9c 81       	ldd	r25, Y+4	; 0x04
     2fc:	fc 01       	movw	r30, r24
     2fe:	80 81       	ld	r24, Z
     300:	21 e0       	ldi	r18, 0x01	; 1
     302:	28 0f       	add	r18, r24
     304:	8b 81       	ldd	r24, Y+3	; 0x03
     306:	9c 81       	ldd	r25, Y+4	; 0x04
     308:	fc 01       	movw	r30, r24
     30a:	20 83       	st	Z, r18
}
     30c:	26 96       	adiw	r28, 0x06	; 6
     30e:	0f b6       	in	r0, 0x3f	; 63
     310:	f8 94       	cli
     312:	de bf       	out	0x3e, r29	; 62
     314:	0f be       	out	0x3f, r0	; 63
     316:	cd bf       	out	0x3d, r28	; 61
     318:	df 91       	pop	r29
     31a:	cf 91       	pop	r28
     31c:	08 95       	ret

0000031e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     31e:	cf 93       	push	r28
     320:	df 93       	push	r29
     322:	cd b7       	in	r28, 0x3d	; 61
     324:	de b7       	in	r29, 0x3e	; 62
     326:	28 97       	sbiw	r28, 0x08	; 8
     328:	0f b6       	in	r0, 0x3f	; 63
     32a:	f8 94       	cli
     32c:	de bf       	out	0x3e, r29	; 62
     32e:	0f be       	out	0x3f, r0	; 63
     330:	cd bf       	out	0x3d, r28	; 61
     332:	9e 83       	std	Y+6, r25	; 0x06
     334:	8d 83       	std	Y+5, r24	; 0x05
     336:	78 87       	std	Y+8, r23	; 0x08
     338:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     33a:	8f 81       	ldd	r24, Y+7	; 0x07
     33c:	98 85       	ldd	r25, Y+8	; 0x08
     33e:	fc 01       	movw	r30, r24
     340:	80 81       	ld	r24, Z
     342:	91 81       	ldd	r25, Z+1	; 0x01
     344:	9c 83       	std	Y+4, r25	; 0x04
     346:	8b 83       	std	Y+3, r24	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     348:	8b 81       	ldd	r24, Y+3	; 0x03
     34a:	9c 81       	ldd	r25, Y+4	; 0x04
     34c:	8f 3f       	cpi	r24, 0xFF	; 255
     34e:	ff ef       	ldi	r31, 0xFF	; 255
     350:	9f 07       	cpc	r25, r31
     352:	41 f4       	brne	.+16     	; 0x364 <vListInsert+0x46>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     354:	8d 81       	ldd	r24, Y+5	; 0x05
     356:	9e 81       	ldd	r25, Y+6	; 0x06
     358:	fc 01       	movw	r30, r24
     35a:	87 81       	ldd	r24, Z+7	; 0x07
     35c:	90 85       	ldd	r25, Z+8	; 0x08
     35e:	9a 83       	std	Y+2, r25	; 0x02
     360:	89 83       	std	Y+1, r24	; 0x01
     362:	1a c0       	rjmp	.+52     	; 0x398 <vListInsert+0x7a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     364:	8d 81       	ldd	r24, Y+5	; 0x05
     366:	9e 81       	ldd	r25, Y+6	; 0x06
     368:	03 96       	adiw	r24, 0x03	; 3
     36a:	9a 83       	std	Y+2, r25	; 0x02
     36c:	89 83       	std	Y+1, r24	; 0x01
     36e:	07 c0       	rjmp	.+14     	; 0x37e <vListInsert+0x60>
     370:	89 81       	ldd	r24, Y+1	; 0x01
     372:	9a 81       	ldd	r25, Y+2	; 0x02
     374:	fc 01       	movw	r30, r24
     376:	82 81       	ldd	r24, Z+2	; 0x02
     378:	93 81       	ldd	r25, Z+3	; 0x03
     37a:	9a 83       	std	Y+2, r25	; 0x02
     37c:	89 83       	std	Y+1, r24	; 0x01
     37e:	89 81       	ldd	r24, Y+1	; 0x01
     380:	9a 81       	ldd	r25, Y+2	; 0x02
     382:	fc 01       	movw	r30, r24
     384:	82 81       	ldd	r24, Z+2	; 0x02
     386:	93 81       	ldd	r25, Z+3	; 0x03
     388:	fc 01       	movw	r30, r24
     38a:	20 81       	ld	r18, Z
     38c:	31 81       	ldd	r19, Z+1	; 0x01
     38e:	8b 81       	ldd	r24, Y+3	; 0x03
     390:	9c 81       	ldd	r25, Y+4	; 0x04
     392:	82 17       	cp	r24, r18
     394:	93 07       	cpc	r25, r19
     396:	60 f7       	brcc	.-40     	; 0x370 <vListInsert+0x52>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     398:	89 81       	ldd	r24, Y+1	; 0x01
     39a:	9a 81       	ldd	r25, Y+2	; 0x02
     39c:	fc 01       	movw	r30, r24
     39e:	22 81       	ldd	r18, Z+2	; 0x02
     3a0:	33 81       	ldd	r19, Z+3	; 0x03
     3a2:	8f 81       	ldd	r24, Y+7	; 0x07
     3a4:	98 85       	ldd	r25, Y+8	; 0x08
     3a6:	fc 01       	movw	r30, r24
     3a8:	33 83       	std	Z+3, r19	; 0x03
     3aa:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     3ac:	8f 81       	ldd	r24, Y+7	; 0x07
     3ae:	98 85       	ldd	r25, Y+8	; 0x08
     3b0:	fc 01       	movw	r30, r24
     3b2:	82 81       	ldd	r24, Z+2	; 0x02
     3b4:	93 81       	ldd	r25, Z+3	; 0x03
     3b6:	2f 81       	ldd	r18, Y+7	; 0x07
     3b8:	38 85       	ldd	r19, Y+8	; 0x08
     3ba:	fc 01       	movw	r30, r24
     3bc:	35 83       	std	Z+5, r19	; 0x05
     3be:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     3c0:	8f 81       	ldd	r24, Y+7	; 0x07
     3c2:	98 85       	ldd	r25, Y+8	; 0x08
     3c4:	29 81       	ldd	r18, Y+1	; 0x01
     3c6:	3a 81       	ldd	r19, Y+2	; 0x02
     3c8:	fc 01       	movw	r30, r24
     3ca:	35 83       	std	Z+5, r19	; 0x05
     3cc:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = pxNewListItem;
     3ce:	89 81       	ldd	r24, Y+1	; 0x01
     3d0:	9a 81       	ldd	r25, Y+2	; 0x02
     3d2:	2f 81       	ldd	r18, Y+7	; 0x07
     3d4:	38 85       	ldd	r19, Y+8	; 0x08
     3d6:	fc 01       	movw	r30, r24
     3d8:	33 83       	std	Z+3, r19	; 0x03
     3da:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     3dc:	8f 81       	ldd	r24, Y+7	; 0x07
     3de:	98 85       	ldd	r25, Y+8	; 0x08
     3e0:	2d 81       	ldd	r18, Y+5	; 0x05
     3e2:	3e 81       	ldd	r19, Y+6	; 0x06
     3e4:	fc 01       	movw	r30, r24
     3e6:	31 87       	std	Z+9, r19	; 0x09
     3e8:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     3ea:	8d 81       	ldd	r24, Y+5	; 0x05
     3ec:	9e 81       	ldd	r25, Y+6	; 0x06
     3ee:	fc 01       	movw	r30, r24
     3f0:	80 81       	ld	r24, Z
     3f2:	21 e0       	ldi	r18, 0x01	; 1
     3f4:	28 0f       	add	r18, r24
     3f6:	8d 81       	ldd	r24, Y+5	; 0x05
     3f8:	9e 81       	ldd	r25, Y+6	; 0x06
     3fa:	fc 01       	movw	r30, r24
     3fc:	20 83       	st	Z, r18
}
     3fe:	28 96       	adiw	r28, 0x08	; 8
     400:	0f b6       	in	r0, 0x3f	; 63
     402:	f8 94       	cli
     404:	de bf       	out	0x3e, r29	; 62
     406:	0f be       	out	0x3f, r0	; 63
     408:	cd bf       	out	0x3d, r28	; 61
     40a:	df 91       	pop	r29
     40c:	cf 91       	pop	r28
     40e:	08 95       	ret

00000410 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     410:	cf 93       	push	r28
     412:	df 93       	push	r29
     414:	00 d0       	rcall	.+0      	; 0x416 <uxListRemove+0x6>
     416:	00 d0       	rcall	.+0      	; 0x418 <uxListRemove+0x8>
     418:	cd b7       	in	r28, 0x3d	; 61
     41a:	de b7       	in	r29, 0x3e	; 62
     41c:	9c 83       	std	Y+4, r25	; 0x04
     41e:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     420:	8b 81       	ldd	r24, Y+3	; 0x03
     422:	9c 81       	ldd	r25, Y+4	; 0x04
     424:	fc 01       	movw	r30, r24
     426:	80 85       	ldd	r24, Z+8	; 0x08
     428:	91 85       	ldd	r25, Z+9	; 0x09
     42a:	9a 83       	std	Y+2, r25	; 0x02
     42c:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     42e:	8b 81       	ldd	r24, Y+3	; 0x03
     430:	9c 81       	ldd	r25, Y+4	; 0x04
     432:	fc 01       	movw	r30, r24
     434:	82 81       	ldd	r24, Z+2	; 0x02
     436:	93 81       	ldd	r25, Z+3	; 0x03
     438:	2b 81       	ldd	r18, Y+3	; 0x03
     43a:	3c 81       	ldd	r19, Y+4	; 0x04
     43c:	f9 01       	movw	r30, r18
     43e:	24 81       	ldd	r18, Z+4	; 0x04
     440:	35 81       	ldd	r19, Z+5	; 0x05
     442:	fc 01       	movw	r30, r24
     444:	35 83       	std	Z+5, r19	; 0x05
     446:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     448:	8b 81       	ldd	r24, Y+3	; 0x03
     44a:	9c 81       	ldd	r25, Y+4	; 0x04
     44c:	fc 01       	movw	r30, r24
     44e:	84 81       	ldd	r24, Z+4	; 0x04
     450:	95 81       	ldd	r25, Z+5	; 0x05
     452:	2b 81       	ldd	r18, Y+3	; 0x03
     454:	3c 81       	ldd	r19, Y+4	; 0x04
     456:	f9 01       	movw	r30, r18
     458:	22 81       	ldd	r18, Z+2	; 0x02
     45a:	33 81       	ldd	r19, Z+3	; 0x03
     45c:	fc 01       	movw	r30, r24
     45e:	33 83       	std	Z+3, r19	; 0x03
     460:	22 83       	std	Z+2, r18	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     462:	89 81       	ldd	r24, Y+1	; 0x01
     464:	9a 81       	ldd	r25, Y+2	; 0x02
     466:	fc 01       	movw	r30, r24
     468:	21 81       	ldd	r18, Z+1	; 0x01
     46a:	32 81       	ldd	r19, Z+2	; 0x02
     46c:	8b 81       	ldd	r24, Y+3	; 0x03
     46e:	9c 81       	ldd	r25, Y+4	; 0x04
     470:	28 17       	cp	r18, r24
     472:	39 07       	cpc	r19, r25
     474:	51 f4       	brne	.+20     	; 0x48a <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     476:	8b 81       	ldd	r24, Y+3	; 0x03
     478:	9c 81       	ldd	r25, Y+4	; 0x04
     47a:	fc 01       	movw	r30, r24
     47c:	24 81       	ldd	r18, Z+4	; 0x04
     47e:	35 81       	ldd	r19, Z+5	; 0x05
     480:	89 81       	ldd	r24, Y+1	; 0x01
     482:	9a 81       	ldd	r25, Y+2	; 0x02
     484:	fc 01       	movw	r30, r24
     486:	32 83       	std	Z+2, r19	; 0x02
     488:	21 83       	std	Z+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     48a:	8b 81       	ldd	r24, Y+3	; 0x03
     48c:	9c 81       	ldd	r25, Y+4	; 0x04
     48e:	fc 01       	movw	r30, r24
     490:	11 86       	std	Z+9, r1	; 0x09
     492:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     494:	89 81       	ldd	r24, Y+1	; 0x01
     496:	9a 81       	ldd	r25, Y+2	; 0x02
     498:	fc 01       	movw	r30, r24
     49a:	80 81       	ld	r24, Z
     49c:	2f ef       	ldi	r18, 0xFF	; 255
     49e:	28 0f       	add	r18, r24
     4a0:	89 81       	ldd	r24, Y+1	; 0x01
     4a2:	9a 81       	ldd	r25, Y+2	; 0x02
     4a4:	fc 01       	movw	r30, r24
     4a6:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
     4a8:	89 81       	ldd	r24, Y+1	; 0x01
     4aa:	9a 81       	ldd	r25, Y+2	; 0x02
     4ac:	fc 01       	movw	r30, r24
     4ae:	80 81       	ld	r24, Z
}
     4b0:	0f 90       	pop	r0
     4b2:	0f 90       	pop	r0
     4b4:	0f 90       	pop	r0
     4b6:	0f 90       	pop	r0
     4b8:	df 91       	pop	r29
     4ba:	cf 91       	pop	r28
     4bc:	08 95       	ret

000004be <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     4be:	cf 93       	push	r28
     4c0:	df 93       	push	r29
     4c2:	00 d0       	rcall	.+0      	; 0x4c4 <pvPortMalloc+0x6>
     4c4:	00 d0       	rcall	.+0      	; 0x4c6 <pvPortMalloc+0x8>
     4c6:	cd b7       	in	r28, 0x3d	; 61
     4c8:	de b7       	in	r29, 0x3e	; 62
     4ca:	9c 83       	std	Y+4, r25	; 0x04
     4cc:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     4ce:	1a 82       	std	Y+2, r1	; 0x02
     4d0:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     4d2:	0e 94 c5 06 	call	0xd8a	; 0xd8a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     4d6:	80 91 10 0a 	lds	r24, 0x0A10
     4da:	90 91 11 0a 	lds	r25, 0x0A11
     4de:	00 97       	sbiw	r24, 0x00	; 0
     4e0:	31 f4       	brne	.+12     	; 0x4ee <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     4e2:	8f e0       	ldi	r24, 0x0F	; 15
     4e4:	92 e0       	ldi	r25, 0x02	; 2
     4e6:	90 93 11 0a 	sts	0x0A11, r25
     4ea:	80 93 10 0a 	sts	0x0A10, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     4ee:	20 91 0e 0a 	lds	r18, 0x0A0E
     4f2:	30 91 0f 0a 	lds	r19, 0x0A0F
     4f6:	8b 81       	ldd	r24, Y+3	; 0x03
     4f8:	9c 81       	ldd	r25, Y+4	; 0x04
     4fa:	82 0f       	add	r24, r18
     4fc:	93 1f       	adc	r25, r19
     4fe:	8f 3f       	cpi	r24, 0xFF	; 255
     500:	27 e0       	ldi	r18, 0x07	; 7
     502:	92 07       	cpc	r25, r18
     504:	38 f5       	brcc	.+78     	; 0x554 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
     506:	20 91 0e 0a 	lds	r18, 0x0A0E
     50a:	30 91 0f 0a 	lds	r19, 0x0A0F
     50e:	8b 81       	ldd	r24, Y+3	; 0x03
     510:	9c 81       	ldd	r25, Y+4	; 0x04
     512:	28 0f       	add	r18, r24
     514:	39 1f       	adc	r19, r25
     516:	80 91 0e 0a 	lds	r24, 0x0A0E
     51a:	90 91 0f 0a 	lds	r25, 0x0A0F
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     51e:	82 17       	cp	r24, r18
     520:	93 07       	cpc	r25, r19
     522:	c0 f4       	brcc	.+48     	; 0x554 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     524:	20 91 10 0a 	lds	r18, 0x0A10
     528:	30 91 11 0a 	lds	r19, 0x0A11
     52c:	80 91 0e 0a 	lds	r24, 0x0A0E
     530:	90 91 0f 0a 	lds	r25, 0x0A0F
     534:	82 0f       	add	r24, r18
     536:	93 1f       	adc	r25, r19
     538:	9a 83       	std	Y+2, r25	; 0x02
     53a:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     53c:	20 91 0e 0a 	lds	r18, 0x0A0E
     540:	30 91 0f 0a 	lds	r19, 0x0A0F
     544:	8b 81       	ldd	r24, Y+3	; 0x03
     546:	9c 81       	ldd	r25, Y+4	; 0x04
     548:	82 0f       	add	r24, r18
     54a:	93 1f       	adc	r25, r19
     54c:	90 93 0f 0a 	sts	0x0A0F, r25
     550:	80 93 0e 0a 	sts	0x0A0E, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     554:	0e 94 d1 06 	call	0xda2	; 0xda2 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     558:	89 81       	ldd	r24, Y+1	; 0x01
     55a:	9a 81       	ldd	r25, Y+2	; 0x02
}
     55c:	0f 90       	pop	r0
     55e:	0f 90       	pop	r0
     560:	0f 90       	pop	r0
     562:	0f 90       	pop	r0
     564:	df 91       	pop	r29
     566:	cf 91       	pop	r28
     568:	08 95       	ret

0000056a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     56a:	cf 93       	push	r28
     56c:	df 93       	push	r29
     56e:	00 d0       	rcall	.+0      	; 0x570 <vPortFree+0x6>
     570:	cd b7       	in	r28, 0x3d	; 61
     572:	de b7       	in	r29, 0x3e	; 62
     574:	9a 83       	std	Y+2, r25	; 0x02
     576:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     578:	0f 90       	pop	r0
     57a:	0f 90       	pop	r0
     57c:	df 91       	pop	r29
     57e:	cf 91       	pop	r28
     580:	08 95       	ret

00000582 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     582:	cf 93       	push	r28
     584:	df 93       	push	r29
     586:	cd b7       	in	r28, 0x3d	; 61
     588:	de b7       	in	r29, 0x3e	; 62
     58a:	28 97       	sbiw	r28, 0x08	; 8
     58c:	0f b6       	in	r0, 0x3f	; 63
     58e:	f8 94       	cli
     590:	de bf       	out	0x3e, r29	; 62
     592:	0f be       	out	0x3f, r0	; 63
     594:	cd bf       	out	0x3d, r28	; 61
     596:	9c 83       	std	Y+4, r25	; 0x04
     598:	8b 83       	std	Y+3, r24	; 0x03
     59a:	7e 83       	std	Y+6, r23	; 0x06
     59c:	6d 83       	std	Y+5, r22	; 0x05
     59e:	58 87       	std	Y+8, r21	; 0x08
     5a0:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     5a2:	8b 81       	ldd	r24, Y+3	; 0x03
     5a4:	9c 81       	ldd	r25, Y+4	; 0x04
     5a6:	21 e1       	ldi	r18, 0x11	; 17
     5a8:	fc 01       	movw	r30, r24
     5aa:	20 83       	st	Z, r18
	pxTopOfStack--;
     5ac:	8b 81       	ldd	r24, Y+3	; 0x03
     5ae:	9c 81       	ldd	r25, Y+4	; 0x04
     5b0:	01 97       	sbiw	r24, 0x01	; 1
     5b2:	9c 83       	std	Y+4, r25	; 0x04
     5b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     5b6:	8b 81       	ldd	r24, Y+3	; 0x03
     5b8:	9c 81       	ldd	r25, Y+4	; 0x04
     5ba:	22 e2       	ldi	r18, 0x22	; 34
     5bc:	fc 01       	movw	r30, r24
     5be:	20 83       	st	Z, r18
	pxTopOfStack--;
     5c0:	8b 81       	ldd	r24, Y+3	; 0x03
     5c2:	9c 81       	ldd	r25, Y+4	; 0x04
     5c4:	01 97       	sbiw	r24, 0x01	; 1
     5c6:	9c 83       	std	Y+4, r25	; 0x04
     5c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     5ca:	8b 81       	ldd	r24, Y+3	; 0x03
     5cc:	9c 81       	ldd	r25, Y+4	; 0x04
     5ce:	23 e3       	ldi	r18, 0x33	; 51
     5d0:	fc 01       	movw	r30, r24
     5d2:	20 83       	st	Z, r18
	pxTopOfStack--;
     5d4:	8b 81       	ldd	r24, Y+3	; 0x03
     5d6:	9c 81       	ldd	r25, Y+4	; 0x04
     5d8:	01 97       	sbiw	r24, 0x01	; 1
     5da:	9c 83       	std	Y+4, r25	; 0x04
     5dc:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     5de:	8d 81       	ldd	r24, Y+5	; 0x05
     5e0:	9e 81       	ldd	r25, Y+6	; 0x06
     5e2:	9a 83       	std	Y+2, r25	; 0x02
     5e4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     5e6:	29 81       	ldd	r18, Y+1	; 0x01
     5e8:	8b 81       	ldd	r24, Y+3	; 0x03
     5ea:	9c 81       	ldd	r25, Y+4	; 0x04
     5ec:	fc 01       	movw	r30, r24
     5ee:	20 83       	st	Z, r18
	pxTopOfStack--;
     5f0:	8b 81       	ldd	r24, Y+3	; 0x03
     5f2:	9c 81       	ldd	r25, Y+4	; 0x04
     5f4:	01 97       	sbiw	r24, 0x01	; 1
     5f6:	9c 83       	std	Y+4, r25	; 0x04
     5f8:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     5fa:	89 81       	ldd	r24, Y+1	; 0x01
     5fc:	9a 81       	ldd	r25, Y+2	; 0x02
     5fe:	89 2f       	mov	r24, r25
     600:	99 27       	eor	r25, r25
     602:	9a 83       	std	Y+2, r25	; 0x02
     604:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     606:	29 81       	ldd	r18, Y+1	; 0x01
     608:	8b 81       	ldd	r24, Y+3	; 0x03
     60a:	9c 81       	ldd	r25, Y+4	; 0x04
     60c:	fc 01       	movw	r30, r24
     60e:	20 83       	st	Z, r18
	pxTopOfStack--;
     610:	8b 81       	ldd	r24, Y+3	; 0x03
     612:	9c 81       	ldd	r25, Y+4	; 0x04
     614:	01 97       	sbiw	r24, 0x01	; 1
     616:	9c 83       	std	Y+4, r25	; 0x04
     618:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     61a:	8b 81       	ldd	r24, Y+3	; 0x03
     61c:	9c 81       	ldd	r25, Y+4	; 0x04
     61e:	fc 01       	movw	r30, r24
     620:	10 82       	st	Z, r1
	pxTopOfStack--;
     622:	8b 81       	ldd	r24, Y+3	; 0x03
     624:	9c 81       	ldd	r25, Y+4	; 0x04
     626:	01 97       	sbiw	r24, 0x01	; 1
     628:	9c 83       	std	Y+4, r25	; 0x04
     62a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     62c:	8b 81       	ldd	r24, Y+3	; 0x03
     62e:	9c 81       	ldd	r25, Y+4	; 0x04
     630:	20 e8       	ldi	r18, 0x80	; 128
     632:	fc 01       	movw	r30, r24
     634:	20 83       	st	Z, r18
	pxTopOfStack--;
     636:	8b 81       	ldd	r24, Y+3	; 0x03
     638:	9c 81       	ldd	r25, Y+4	; 0x04
     63a:	01 97       	sbiw	r24, 0x01	; 1
     63c:	9c 83       	std	Y+4, r25	; 0x04
     63e:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     640:	8b 81       	ldd	r24, Y+3	; 0x03
     642:	9c 81       	ldd	r25, Y+4	; 0x04
     644:	fc 01       	movw	r30, r24
     646:	10 82       	st	Z, r1
	pxTopOfStack--;
     648:	8b 81       	ldd	r24, Y+3	; 0x03
     64a:	9c 81       	ldd	r25, Y+4	; 0x04
     64c:	01 97       	sbiw	r24, 0x01	; 1
     64e:	9c 83       	std	Y+4, r25	; 0x04
     650:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     652:	8b 81       	ldd	r24, Y+3	; 0x03
     654:	9c 81       	ldd	r25, Y+4	; 0x04
     656:	22 e0       	ldi	r18, 0x02	; 2
     658:	fc 01       	movw	r30, r24
     65a:	20 83       	st	Z, r18
	pxTopOfStack--;
     65c:	8b 81       	ldd	r24, Y+3	; 0x03
     65e:	9c 81       	ldd	r25, Y+4	; 0x04
     660:	01 97       	sbiw	r24, 0x01	; 1
     662:	9c 83       	std	Y+4, r25	; 0x04
     664:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     666:	8b 81       	ldd	r24, Y+3	; 0x03
     668:	9c 81       	ldd	r25, Y+4	; 0x04
     66a:	23 e0       	ldi	r18, 0x03	; 3
     66c:	fc 01       	movw	r30, r24
     66e:	20 83       	st	Z, r18
	pxTopOfStack--;
     670:	8b 81       	ldd	r24, Y+3	; 0x03
     672:	9c 81       	ldd	r25, Y+4	; 0x04
     674:	01 97       	sbiw	r24, 0x01	; 1
     676:	9c 83       	std	Y+4, r25	; 0x04
     678:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     67a:	8b 81       	ldd	r24, Y+3	; 0x03
     67c:	9c 81       	ldd	r25, Y+4	; 0x04
     67e:	24 e0       	ldi	r18, 0x04	; 4
     680:	fc 01       	movw	r30, r24
     682:	20 83       	st	Z, r18
	pxTopOfStack--;
     684:	8b 81       	ldd	r24, Y+3	; 0x03
     686:	9c 81       	ldd	r25, Y+4	; 0x04
     688:	01 97       	sbiw	r24, 0x01	; 1
     68a:	9c 83       	std	Y+4, r25	; 0x04
     68c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     68e:	8b 81       	ldd	r24, Y+3	; 0x03
     690:	9c 81       	ldd	r25, Y+4	; 0x04
     692:	25 e0       	ldi	r18, 0x05	; 5
     694:	fc 01       	movw	r30, r24
     696:	20 83       	st	Z, r18
	pxTopOfStack--;
     698:	8b 81       	ldd	r24, Y+3	; 0x03
     69a:	9c 81       	ldd	r25, Y+4	; 0x04
     69c:	01 97       	sbiw	r24, 0x01	; 1
     69e:	9c 83       	std	Y+4, r25	; 0x04
     6a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     6a2:	8b 81       	ldd	r24, Y+3	; 0x03
     6a4:	9c 81       	ldd	r25, Y+4	; 0x04
     6a6:	26 e0       	ldi	r18, 0x06	; 6
     6a8:	fc 01       	movw	r30, r24
     6aa:	20 83       	st	Z, r18
	pxTopOfStack--;
     6ac:	8b 81       	ldd	r24, Y+3	; 0x03
     6ae:	9c 81       	ldd	r25, Y+4	; 0x04
     6b0:	01 97       	sbiw	r24, 0x01	; 1
     6b2:	9c 83       	std	Y+4, r25	; 0x04
     6b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     6b6:	8b 81       	ldd	r24, Y+3	; 0x03
     6b8:	9c 81       	ldd	r25, Y+4	; 0x04
     6ba:	27 e0       	ldi	r18, 0x07	; 7
     6bc:	fc 01       	movw	r30, r24
     6be:	20 83       	st	Z, r18
	pxTopOfStack--;
     6c0:	8b 81       	ldd	r24, Y+3	; 0x03
     6c2:	9c 81       	ldd	r25, Y+4	; 0x04
     6c4:	01 97       	sbiw	r24, 0x01	; 1
     6c6:	9c 83       	std	Y+4, r25	; 0x04
     6c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     6ca:	8b 81       	ldd	r24, Y+3	; 0x03
     6cc:	9c 81       	ldd	r25, Y+4	; 0x04
     6ce:	28 e0       	ldi	r18, 0x08	; 8
     6d0:	fc 01       	movw	r30, r24
     6d2:	20 83       	st	Z, r18
	pxTopOfStack--;
     6d4:	8b 81       	ldd	r24, Y+3	; 0x03
     6d6:	9c 81       	ldd	r25, Y+4	; 0x04
     6d8:	01 97       	sbiw	r24, 0x01	; 1
     6da:	9c 83       	std	Y+4, r25	; 0x04
     6dc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     6de:	8b 81       	ldd	r24, Y+3	; 0x03
     6e0:	9c 81       	ldd	r25, Y+4	; 0x04
     6e2:	29 e0       	ldi	r18, 0x09	; 9
     6e4:	fc 01       	movw	r30, r24
     6e6:	20 83       	st	Z, r18
	pxTopOfStack--;
     6e8:	8b 81       	ldd	r24, Y+3	; 0x03
     6ea:	9c 81       	ldd	r25, Y+4	; 0x04
     6ec:	01 97       	sbiw	r24, 0x01	; 1
     6ee:	9c 83       	std	Y+4, r25	; 0x04
     6f0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     6f2:	8b 81       	ldd	r24, Y+3	; 0x03
     6f4:	9c 81       	ldd	r25, Y+4	; 0x04
     6f6:	20 e1       	ldi	r18, 0x10	; 16
     6f8:	fc 01       	movw	r30, r24
     6fa:	20 83       	st	Z, r18
	pxTopOfStack--;
     6fc:	8b 81       	ldd	r24, Y+3	; 0x03
     6fe:	9c 81       	ldd	r25, Y+4	; 0x04
     700:	01 97       	sbiw	r24, 0x01	; 1
     702:	9c 83       	std	Y+4, r25	; 0x04
     704:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     706:	8b 81       	ldd	r24, Y+3	; 0x03
     708:	9c 81       	ldd	r25, Y+4	; 0x04
     70a:	21 e1       	ldi	r18, 0x11	; 17
     70c:	fc 01       	movw	r30, r24
     70e:	20 83       	st	Z, r18
	pxTopOfStack--;
     710:	8b 81       	ldd	r24, Y+3	; 0x03
     712:	9c 81       	ldd	r25, Y+4	; 0x04
     714:	01 97       	sbiw	r24, 0x01	; 1
     716:	9c 83       	std	Y+4, r25	; 0x04
     718:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     71a:	8b 81       	ldd	r24, Y+3	; 0x03
     71c:	9c 81       	ldd	r25, Y+4	; 0x04
     71e:	22 e1       	ldi	r18, 0x12	; 18
     720:	fc 01       	movw	r30, r24
     722:	20 83       	st	Z, r18
	pxTopOfStack--;
     724:	8b 81       	ldd	r24, Y+3	; 0x03
     726:	9c 81       	ldd	r25, Y+4	; 0x04
     728:	01 97       	sbiw	r24, 0x01	; 1
     72a:	9c 83       	std	Y+4, r25	; 0x04
     72c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     72e:	8b 81       	ldd	r24, Y+3	; 0x03
     730:	9c 81       	ldd	r25, Y+4	; 0x04
     732:	23 e1       	ldi	r18, 0x13	; 19
     734:	fc 01       	movw	r30, r24
     736:	20 83       	st	Z, r18
	pxTopOfStack--;
     738:	8b 81       	ldd	r24, Y+3	; 0x03
     73a:	9c 81       	ldd	r25, Y+4	; 0x04
     73c:	01 97       	sbiw	r24, 0x01	; 1
     73e:	9c 83       	std	Y+4, r25	; 0x04
     740:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     742:	8b 81       	ldd	r24, Y+3	; 0x03
     744:	9c 81       	ldd	r25, Y+4	; 0x04
     746:	24 e1       	ldi	r18, 0x14	; 20
     748:	fc 01       	movw	r30, r24
     74a:	20 83       	st	Z, r18
	pxTopOfStack--;
     74c:	8b 81       	ldd	r24, Y+3	; 0x03
     74e:	9c 81       	ldd	r25, Y+4	; 0x04
     750:	01 97       	sbiw	r24, 0x01	; 1
     752:	9c 83       	std	Y+4, r25	; 0x04
     754:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     756:	8b 81       	ldd	r24, Y+3	; 0x03
     758:	9c 81       	ldd	r25, Y+4	; 0x04
     75a:	25 e1       	ldi	r18, 0x15	; 21
     75c:	fc 01       	movw	r30, r24
     75e:	20 83       	st	Z, r18
	pxTopOfStack--;
     760:	8b 81       	ldd	r24, Y+3	; 0x03
     762:	9c 81       	ldd	r25, Y+4	; 0x04
     764:	01 97       	sbiw	r24, 0x01	; 1
     766:	9c 83       	std	Y+4, r25	; 0x04
     768:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     76a:	8b 81       	ldd	r24, Y+3	; 0x03
     76c:	9c 81       	ldd	r25, Y+4	; 0x04
     76e:	26 e1       	ldi	r18, 0x16	; 22
     770:	fc 01       	movw	r30, r24
     772:	20 83       	st	Z, r18
	pxTopOfStack--;
     774:	8b 81       	ldd	r24, Y+3	; 0x03
     776:	9c 81       	ldd	r25, Y+4	; 0x04
     778:	01 97       	sbiw	r24, 0x01	; 1
     77a:	9c 83       	std	Y+4, r25	; 0x04
     77c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     77e:	8b 81       	ldd	r24, Y+3	; 0x03
     780:	9c 81       	ldd	r25, Y+4	; 0x04
     782:	27 e1       	ldi	r18, 0x17	; 23
     784:	fc 01       	movw	r30, r24
     786:	20 83       	st	Z, r18
	pxTopOfStack--;
     788:	8b 81       	ldd	r24, Y+3	; 0x03
     78a:	9c 81       	ldd	r25, Y+4	; 0x04
     78c:	01 97       	sbiw	r24, 0x01	; 1
     78e:	9c 83       	std	Y+4, r25	; 0x04
     790:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     792:	8b 81       	ldd	r24, Y+3	; 0x03
     794:	9c 81       	ldd	r25, Y+4	; 0x04
     796:	28 e1       	ldi	r18, 0x18	; 24
     798:	fc 01       	movw	r30, r24
     79a:	20 83       	st	Z, r18
	pxTopOfStack--;
     79c:	8b 81       	ldd	r24, Y+3	; 0x03
     79e:	9c 81       	ldd	r25, Y+4	; 0x04
     7a0:	01 97       	sbiw	r24, 0x01	; 1
     7a2:	9c 83       	std	Y+4, r25	; 0x04
     7a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     7a6:	8b 81       	ldd	r24, Y+3	; 0x03
     7a8:	9c 81       	ldd	r25, Y+4	; 0x04
     7aa:	29 e1       	ldi	r18, 0x19	; 25
     7ac:	fc 01       	movw	r30, r24
     7ae:	20 83       	st	Z, r18
	pxTopOfStack--;
     7b0:	8b 81       	ldd	r24, Y+3	; 0x03
     7b2:	9c 81       	ldd	r25, Y+4	; 0x04
     7b4:	01 97       	sbiw	r24, 0x01	; 1
     7b6:	9c 83       	std	Y+4, r25	; 0x04
     7b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     7ba:	8b 81       	ldd	r24, Y+3	; 0x03
     7bc:	9c 81       	ldd	r25, Y+4	; 0x04
     7be:	20 e2       	ldi	r18, 0x20	; 32
     7c0:	fc 01       	movw	r30, r24
     7c2:	20 83       	st	Z, r18
	pxTopOfStack--;
     7c4:	8b 81       	ldd	r24, Y+3	; 0x03
     7c6:	9c 81       	ldd	r25, Y+4	; 0x04
     7c8:	01 97       	sbiw	r24, 0x01	; 1
     7ca:	9c 83       	std	Y+4, r25	; 0x04
     7cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     7ce:	8b 81       	ldd	r24, Y+3	; 0x03
     7d0:	9c 81       	ldd	r25, Y+4	; 0x04
     7d2:	21 e2       	ldi	r18, 0x21	; 33
     7d4:	fc 01       	movw	r30, r24
     7d6:	20 83       	st	Z, r18
	pxTopOfStack--;
     7d8:	8b 81       	ldd	r24, Y+3	; 0x03
     7da:	9c 81       	ldd	r25, Y+4	; 0x04
     7dc:	01 97       	sbiw	r24, 0x01	; 1
     7de:	9c 83       	std	Y+4, r25	; 0x04
     7e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     7e2:	8b 81       	ldd	r24, Y+3	; 0x03
     7e4:	9c 81       	ldd	r25, Y+4	; 0x04
     7e6:	22 e2       	ldi	r18, 0x22	; 34
     7e8:	fc 01       	movw	r30, r24
     7ea:	20 83       	st	Z, r18
	pxTopOfStack--;
     7ec:	8b 81       	ldd	r24, Y+3	; 0x03
     7ee:	9c 81       	ldd	r25, Y+4	; 0x04
     7f0:	01 97       	sbiw	r24, 0x01	; 1
     7f2:	9c 83       	std	Y+4, r25	; 0x04
     7f4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     7f6:	8b 81       	ldd	r24, Y+3	; 0x03
     7f8:	9c 81       	ldd	r25, Y+4	; 0x04
     7fa:	23 e2       	ldi	r18, 0x23	; 35
     7fc:	fc 01       	movw	r30, r24
     7fe:	20 83       	st	Z, r18
	pxTopOfStack--;
     800:	8b 81       	ldd	r24, Y+3	; 0x03
     802:	9c 81       	ldd	r25, Y+4	; 0x04
     804:	01 97       	sbiw	r24, 0x01	; 1
     806:	9c 83       	std	Y+4, r25	; 0x04
     808:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     80a:	8f 81       	ldd	r24, Y+7	; 0x07
     80c:	98 85       	ldd	r25, Y+8	; 0x08
     80e:	9a 83       	std	Y+2, r25	; 0x02
     810:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     812:	29 81       	ldd	r18, Y+1	; 0x01
     814:	8b 81       	ldd	r24, Y+3	; 0x03
     816:	9c 81       	ldd	r25, Y+4	; 0x04
     818:	fc 01       	movw	r30, r24
     81a:	20 83       	st	Z, r18
	pxTopOfStack--;
     81c:	8b 81       	ldd	r24, Y+3	; 0x03
     81e:	9c 81       	ldd	r25, Y+4	; 0x04
     820:	01 97       	sbiw	r24, 0x01	; 1
     822:	9c 83       	std	Y+4, r25	; 0x04
     824:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     826:	89 81       	ldd	r24, Y+1	; 0x01
     828:	9a 81       	ldd	r25, Y+2	; 0x02
     82a:	89 2f       	mov	r24, r25
     82c:	99 27       	eor	r25, r25
     82e:	9a 83       	std	Y+2, r25	; 0x02
     830:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     832:	29 81       	ldd	r18, Y+1	; 0x01
     834:	8b 81       	ldd	r24, Y+3	; 0x03
     836:	9c 81       	ldd	r25, Y+4	; 0x04
     838:	fc 01       	movw	r30, r24
     83a:	20 83       	st	Z, r18
	pxTopOfStack--;
     83c:	8b 81       	ldd	r24, Y+3	; 0x03
     83e:	9c 81       	ldd	r25, Y+4	; 0x04
     840:	01 97       	sbiw	r24, 0x01	; 1
     842:	9c 83       	std	Y+4, r25	; 0x04
     844:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     846:	8b 81       	ldd	r24, Y+3	; 0x03
     848:	9c 81       	ldd	r25, Y+4	; 0x04
     84a:	26 e2       	ldi	r18, 0x26	; 38
     84c:	fc 01       	movw	r30, r24
     84e:	20 83       	st	Z, r18
	pxTopOfStack--;
     850:	8b 81       	ldd	r24, Y+3	; 0x03
     852:	9c 81       	ldd	r25, Y+4	; 0x04
     854:	01 97       	sbiw	r24, 0x01	; 1
     856:	9c 83       	std	Y+4, r25	; 0x04
     858:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     85a:	8b 81       	ldd	r24, Y+3	; 0x03
     85c:	9c 81       	ldd	r25, Y+4	; 0x04
     85e:	27 e2       	ldi	r18, 0x27	; 39
     860:	fc 01       	movw	r30, r24
     862:	20 83       	st	Z, r18
	pxTopOfStack--;
     864:	8b 81       	ldd	r24, Y+3	; 0x03
     866:	9c 81       	ldd	r25, Y+4	; 0x04
     868:	01 97       	sbiw	r24, 0x01	; 1
     86a:	9c 83       	std	Y+4, r25	; 0x04
     86c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     86e:	8b 81       	ldd	r24, Y+3	; 0x03
     870:	9c 81       	ldd	r25, Y+4	; 0x04
     872:	28 e2       	ldi	r18, 0x28	; 40
     874:	fc 01       	movw	r30, r24
     876:	20 83       	st	Z, r18
	pxTopOfStack--;
     878:	8b 81       	ldd	r24, Y+3	; 0x03
     87a:	9c 81       	ldd	r25, Y+4	; 0x04
     87c:	01 97       	sbiw	r24, 0x01	; 1
     87e:	9c 83       	std	Y+4, r25	; 0x04
     880:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     882:	8b 81       	ldd	r24, Y+3	; 0x03
     884:	9c 81       	ldd	r25, Y+4	; 0x04
     886:	29 e2       	ldi	r18, 0x29	; 41
     888:	fc 01       	movw	r30, r24
     88a:	20 83       	st	Z, r18
	pxTopOfStack--;
     88c:	8b 81       	ldd	r24, Y+3	; 0x03
     88e:	9c 81       	ldd	r25, Y+4	; 0x04
     890:	01 97       	sbiw	r24, 0x01	; 1
     892:	9c 83       	std	Y+4, r25	; 0x04
     894:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     896:	8b 81       	ldd	r24, Y+3	; 0x03
     898:	9c 81       	ldd	r25, Y+4	; 0x04
     89a:	20 e3       	ldi	r18, 0x30	; 48
     89c:	fc 01       	movw	r30, r24
     89e:	20 83       	st	Z, r18
	pxTopOfStack--;
     8a0:	8b 81       	ldd	r24, Y+3	; 0x03
     8a2:	9c 81       	ldd	r25, Y+4	; 0x04
     8a4:	01 97       	sbiw	r24, 0x01	; 1
     8a6:	9c 83       	std	Y+4, r25	; 0x04
     8a8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     8aa:	8b 81       	ldd	r24, Y+3	; 0x03
     8ac:	9c 81       	ldd	r25, Y+4	; 0x04
     8ae:	21 e3       	ldi	r18, 0x31	; 49
     8b0:	fc 01       	movw	r30, r24
     8b2:	20 83       	st	Z, r18
	pxTopOfStack--;
     8b4:	8b 81       	ldd	r24, Y+3	; 0x03
     8b6:	9c 81       	ldd	r25, Y+4	; 0x04
     8b8:	01 97       	sbiw	r24, 0x01	; 1
     8ba:	9c 83       	std	Y+4, r25	; 0x04
     8bc:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     8be:	8b 81       	ldd	r24, Y+3	; 0x03
     8c0:	9c 81       	ldd	r25, Y+4	; 0x04
}
     8c2:	28 96       	adiw	r28, 0x08	; 8
     8c4:	0f b6       	in	r0, 0x3f	; 63
     8c6:	f8 94       	cli
     8c8:	de bf       	out	0x3e, r29	; 62
     8ca:	0f be       	out	0x3f, r0	; 63
     8cc:	cd bf       	out	0x3d, r28	; 61
     8ce:	df 91       	pop	r29
     8d0:	cf 91       	pop	r28
     8d2:	08 95       	ret

000008d4 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     8d4:	cf 93       	push	r28
     8d6:	df 93       	push	r29
     8d8:	cd b7       	in	r28, 0x3d	; 61
     8da:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     8dc:	0e 94 55 05 	call	0xaaa	; 0xaaa <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     8e0:	a0 91 12 0a 	lds	r26, 0x0A12
     8e4:	b0 91 13 0a 	lds	r27, 0x0A13
     8e8:	cd 91       	ld	r28, X+
     8ea:	cd bf       	out	0x3d, r28	; 61
     8ec:	dd 91       	ld	r29, X+
     8ee:	de bf       	out	0x3e, r29	; 62
     8f0:	ff 91       	pop	r31
     8f2:	ef 91       	pop	r30
     8f4:	df 91       	pop	r29
     8f6:	cf 91       	pop	r28
     8f8:	bf 91       	pop	r27
     8fa:	af 91       	pop	r26
     8fc:	9f 91       	pop	r25
     8fe:	8f 91       	pop	r24
     900:	7f 91       	pop	r23
     902:	6f 91       	pop	r22
     904:	5f 91       	pop	r21
     906:	4f 91       	pop	r20
     908:	3f 91       	pop	r19
     90a:	2f 91       	pop	r18
     90c:	1f 91       	pop	r17
     90e:	0f 91       	pop	r16
     910:	ff 90       	pop	r15
     912:	ef 90       	pop	r14
     914:	df 90       	pop	r13
     916:	cf 90       	pop	r12
     918:	bf 90       	pop	r11
     91a:	af 90       	pop	r10
     91c:	9f 90       	pop	r9
     91e:	8f 90       	pop	r8
     920:	7f 90       	pop	r7
     922:	6f 90       	pop	r6
     924:	5f 90       	pop	r5
     926:	4f 90       	pop	r4
     928:	3f 90       	pop	r3
     92a:	2f 90       	pop	r2
     92c:	1f 90       	pop	r1
     92e:	0f 90       	pop	r0
     930:	0f be       	out	0x3f, r0	; 63
     932:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     934:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     936:	81 e0       	ldi	r24, 0x01	; 1
}
     938:	df 91       	pop	r29
     93a:	cf 91       	pop	r28
     93c:	08 95       	ret

0000093e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     93e:	0f 92       	push	r0
     940:	0f b6       	in	r0, 0x3f	; 63
     942:	f8 94       	cli
     944:	0f 92       	push	r0
     946:	1f 92       	push	r1
     948:	11 24       	eor	r1, r1
     94a:	2f 92       	push	r2
     94c:	3f 92       	push	r3
     94e:	4f 92       	push	r4
     950:	5f 92       	push	r5
     952:	6f 92       	push	r6
     954:	7f 92       	push	r7
     956:	8f 92       	push	r8
     958:	9f 92       	push	r9
     95a:	af 92       	push	r10
     95c:	bf 92       	push	r11
     95e:	cf 92       	push	r12
     960:	df 92       	push	r13
     962:	ef 92       	push	r14
     964:	ff 92       	push	r15
     966:	0f 93       	push	r16
     968:	1f 93       	push	r17
     96a:	2f 93       	push	r18
     96c:	3f 93       	push	r19
     96e:	4f 93       	push	r20
     970:	5f 93       	push	r21
     972:	6f 93       	push	r22
     974:	7f 93       	push	r23
     976:	8f 93       	push	r24
     978:	9f 93       	push	r25
     97a:	af 93       	push	r26
     97c:	bf 93       	push	r27
     97e:	cf 93       	push	r28
     980:	df 93       	push	r29
     982:	ef 93       	push	r30
     984:	ff 93       	push	r31
     986:	a0 91 12 0a 	lds	r26, 0x0A12
     98a:	b0 91 13 0a 	lds	r27, 0x0A13
     98e:	0d b6       	in	r0, 0x3d	; 61
     990:	0d 92       	st	X+, r0
     992:	0e b6       	in	r0, 0x3e	; 62
     994:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     996:	0e 94 4d 08 	call	0x109a	; 0x109a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     99a:	a0 91 12 0a 	lds	r26, 0x0A12
     99e:	b0 91 13 0a 	lds	r27, 0x0A13
     9a2:	cd 91       	ld	r28, X+
     9a4:	cd bf       	out	0x3d, r28	; 61
     9a6:	dd 91       	ld	r29, X+
     9a8:	de bf       	out	0x3e, r29	; 62
     9aa:	ff 91       	pop	r31
     9ac:	ef 91       	pop	r30
     9ae:	df 91       	pop	r29
     9b0:	cf 91       	pop	r28
     9b2:	bf 91       	pop	r27
     9b4:	af 91       	pop	r26
     9b6:	9f 91       	pop	r25
     9b8:	8f 91       	pop	r24
     9ba:	7f 91       	pop	r23
     9bc:	6f 91       	pop	r22
     9be:	5f 91       	pop	r21
     9c0:	4f 91       	pop	r20
     9c2:	3f 91       	pop	r19
     9c4:	2f 91       	pop	r18
     9c6:	1f 91       	pop	r17
     9c8:	0f 91       	pop	r16
     9ca:	ff 90       	pop	r15
     9cc:	ef 90       	pop	r14
     9ce:	df 90       	pop	r13
     9d0:	cf 90       	pop	r12
     9d2:	bf 90       	pop	r11
     9d4:	af 90       	pop	r10
     9d6:	9f 90       	pop	r9
     9d8:	8f 90       	pop	r8
     9da:	7f 90       	pop	r7
     9dc:	6f 90       	pop	r6
     9de:	5f 90       	pop	r5
     9e0:	4f 90       	pop	r4
     9e2:	3f 90       	pop	r3
     9e4:	2f 90       	pop	r2
     9e6:	1f 90       	pop	r1
     9e8:	0f 90       	pop	r0
     9ea:	0f be       	out	0x3f, r0	; 63
     9ec:	0f 90       	pop	r0

	asm volatile ( "ret" );
     9ee:	08 95       	ret

000009f0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     9f0:	0f 92       	push	r0
     9f2:	0f b6       	in	r0, 0x3f	; 63
     9f4:	f8 94       	cli
     9f6:	0f 92       	push	r0
     9f8:	1f 92       	push	r1
     9fa:	11 24       	eor	r1, r1
     9fc:	2f 92       	push	r2
     9fe:	3f 92       	push	r3
     a00:	4f 92       	push	r4
     a02:	5f 92       	push	r5
     a04:	6f 92       	push	r6
     a06:	7f 92       	push	r7
     a08:	8f 92       	push	r8
     a0a:	9f 92       	push	r9
     a0c:	af 92       	push	r10
     a0e:	bf 92       	push	r11
     a10:	cf 92       	push	r12
     a12:	df 92       	push	r13
     a14:	ef 92       	push	r14
     a16:	ff 92       	push	r15
     a18:	0f 93       	push	r16
     a1a:	1f 93       	push	r17
     a1c:	2f 93       	push	r18
     a1e:	3f 93       	push	r19
     a20:	4f 93       	push	r20
     a22:	5f 93       	push	r21
     a24:	6f 93       	push	r22
     a26:	7f 93       	push	r23
     a28:	8f 93       	push	r24
     a2a:	9f 93       	push	r25
     a2c:	af 93       	push	r26
     a2e:	bf 93       	push	r27
     a30:	cf 93       	push	r28
     a32:	df 93       	push	r29
     a34:	ef 93       	push	r30
     a36:	ff 93       	push	r31
     a38:	a0 91 12 0a 	lds	r26, 0x0A12
     a3c:	b0 91 13 0a 	lds	r27, 0x0A13
     a40:	0d b6       	in	r0, 0x3d	; 61
     a42:	0d 92       	st	X+, r0
     a44:	0e b6       	in	r0, 0x3e	; 62
     a46:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     a48:	0e 94 5f 07 	call	0xebe	; 0xebe <xTaskIncrementTick>
     a4c:	88 23       	and	r24, r24
     a4e:	11 f0       	breq	.+4      	; 0xa54 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     a50:	0e 94 4d 08 	call	0x109a	; 0x109a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     a54:	a0 91 12 0a 	lds	r26, 0x0A12
     a58:	b0 91 13 0a 	lds	r27, 0x0A13
     a5c:	cd 91       	ld	r28, X+
     a5e:	cd bf       	out	0x3d, r28	; 61
     a60:	dd 91       	ld	r29, X+
     a62:	de bf       	out	0x3e, r29	; 62
     a64:	ff 91       	pop	r31
     a66:	ef 91       	pop	r30
     a68:	df 91       	pop	r29
     a6a:	cf 91       	pop	r28
     a6c:	bf 91       	pop	r27
     a6e:	af 91       	pop	r26
     a70:	9f 91       	pop	r25
     a72:	8f 91       	pop	r24
     a74:	7f 91       	pop	r23
     a76:	6f 91       	pop	r22
     a78:	5f 91       	pop	r21
     a7a:	4f 91       	pop	r20
     a7c:	3f 91       	pop	r19
     a7e:	2f 91       	pop	r18
     a80:	1f 91       	pop	r17
     a82:	0f 91       	pop	r16
     a84:	ff 90       	pop	r15
     a86:	ef 90       	pop	r14
     a88:	df 90       	pop	r13
     a8a:	cf 90       	pop	r12
     a8c:	bf 90       	pop	r11
     a8e:	af 90       	pop	r10
     a90:	9f 90       	pop	r9
     a92:	8f 90       	pop	r8
     a94:	7f 90       	pop	r7
     a96:	6f 90       	pop	r6
     a98:	5f 90       	pop	r5
     a9a:	4f 90       	pop	r4
     a9c:	3f 90       	pop	r3
     a9e:	2f 90       	pop	r2
     aa0:	1f 90       	pop	r1
     aa2:	0f 90       	pop	r0
     aa4:	0f be       	out	0x3f, r0	; 63
     aa6:	0f 90       	pop	r0

	asm volatile ( "ret" );
     aa8:	08 95       	ret

00000aaa <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     aaa:	cf 93       	push	r28
     aac:	df 93       	push	r29
     aae:	cd b7       	in	r28, 0x3d	; 61
     ab0:	de b7       	in	r29, 0x3e	; 62
	TCNT0=0x00;
     ab2:	86 e4       	ldi	r24, 0x46	; 70
     ab4:	90 e0       	ldi	r25, 0x00	; 0
     ab6:	fc 01       	movw	r30, r24
     ab8:	10 82       	st	Z, r1
	OCR0A = 249;
     aba:	87 e4       	ldi	r24, 0x47	; 71
     abc:	90 e0       	ldi	r25, 0x00	; 0
     abe:	29 ef       	ldi	r18, 0xF9	; 249
     ac0:	fc 01       	movw	r30, r24
     ac2:	20 83       	st	Z, r18
	TCCR0A = 0b00000010;
     ac4:	84 e4       	ldi	r24, 0x44	; 68
     ac6:	90 e0       	ldi	r25, 0x00	; 0
     ac8:	22 e0       	ldi	r18, 0x02	; 2
     aca:	fc 01       	movw	r30, r24
     acc:	20 83       	st	Z, r18
	TCCR0B = 0b00000011;
     ace:	85 e4       	ldi	r24, 0x45	; 69
     ad0:	90 e0       	ldi	r25, 0x00	; 0
     ad2:	23 e0       	ldi	r18, 0x03	; 3
     ad4:	fc 01       	movw	r30, r24
     ad6:	20 83       	st	Z, r18
	TIMSK0 = 0b00000010;
     ad8:	8e e6       	ldi	r24, 0x6E	; 110
     ada:	90 e0       	ldi	r25, 0x00	; 0
     adc:	22 e0       	ldi	r18, 0x02	; 2
     ade:	fc 01       	movw	r30, r24
     ae0:	20 83       	st	Z, r18
}
     ae2:	df 91       	pop	r29
     ae4:	cf 91       	pop	r28
     ae6:	08 95       	ret

00000ae8 <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
     ae8:	af 92       	push	r10
     aea:	bf 92       	push	r11
     aec:	cf 92       	push	r12
     aee:	df 92       	push	r13
     af0:	ef 92       	push	r14
     af2:	ff 92       	push	r15
     af4:	0f 93       	push	r16
     af6:	1f 93       	push	r17
     af8:	cf 93       	push	r28
     afa:	df 93       	push	r29
     afc:	cd b7       	in	r28, 0x3d	; 61
     afe:	de b7       	in	r29, 0x3e	; 62
     b00:	64 97       	sbiw	r28, 0x14	; 20
     b02:	0f b6       	in	r0, 0x3f	; 63
     b04:	f8 94       	cli
     b06:	de bf       	out	0x3e, r29	; 62
     b08:	0f be       	out	0x3f, r0	; 63
     b0a:	cd bf       	out	0x3d, r28	; 61
     b0c:	9f 83       	std	Y+7, r25	; 0x07
     b0e:	8e 83       	std	Y+6, r24	; 0x06
     b10:	79 87       	std	Y+9, r23	; 0x09
     b12:	68 87       	std	Y+8, r22	; 0x08
     b14:	5b 87       	std	Y+11, r21	; 0x0b
     b16:	4a 87       	std	Y+10, r20	; 0x0a
     b18:	3d 87       	std	Y+13, r19	; 0x0d
     b1a:	2c 87       	std	Y+12, r18	; 0x0c
     b1c:	0e 87       	std	Y+14, r16	; 0x0e
     b1e:	f8 8a       	std	Y+16, r15	; 0x10
     b20:	ef 86       	std	Y+15, r14	; 0x0f
     b22:	da 8a       	std	Y+18, r13	; 0x12
     b24:	c9 8a       	std	Y+17, r12	; 0x11
     b26:	bc 8a       	std	Y+20, r11	; 0x14
     b28:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
     b2a:	29 89       	ldd	r18, Y+17	; 0x11
     b2c:	3a 89       	ldd	r19, Y+18	; 0x12
     b2e:	8a 85       	ldd	r24, Y+10	; 0x0a
     b30:	9b 85       	ldd	r25, Y+11	; 0x0b
     b32:	b9 01       	movw	r22, r18
     b34:	0e 94 19 0a 	call	0x1432	; 0x1432 <prvAllocateTCBAndStack>
     b38:	9b 83       	std	Y+3, r25	; 0x03
     b3a:	8a 83       	std	Y+2, r24	; 0x02

	if( pxNewTCB != NULL )
     b3c:	8a 81       	ldd	r24, Y+2	; 0x02
     b3e:	9b 81       	ldd	r25, Y+3	; 0x03
     b40:	00 97       	sbiw	r24, 0x00	; 0
     b42:	09 f4       	brne	.+2      	; 0xb46 <xTaskGenericCreate+0x5e>
     b44:	91 c0       	rjmp	.+290    	; 0xc68 <xTaskGenericCreate+0x180>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
     b46:	8a 81       	ldd	r24, Y+2	; 0x02
     b48:	9b 81       	ldd	r25, Y+3	; 0x03
     b4a:	fc 01       	movw	r30, r24
     b4c:	27 89       	ldd	r18, Z+23	; 0x17
     b4e:	30 8d       	ldd	r19, Z+24	; 0x18
     b50:	8a 85       	ldd	r24, Y+10	; 0x0a
     b52:	9b 85       	ldd	r25, Y+11	; 0x0b
     b54:	01 97       	sbiw	r24, 0x01	; 1
     b56:	82 0f       	add	r24, r18
     b58:	93 1f       	adc	r25, r19
     b5a:	9d 83       	std	Y+5, r25	; 0x05
     b5c:	8c 83       	std	Y+4, r24	; 0x04
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
     b5e:	4a 85       	ldd	r20, Y+10	; 0x0a
     b60:	5b 85       	ldd	r21, Y+11	; 0x0b
     b62:	2b 89       	ldd	r18, Y+19	; 0x13
     b64:	3c 89       	ldd	r19, Y+20	; 0x14
     b66:	68 85       	ldd	r22, Y+8	; 0x08
     b68:	79 85       	ldd	r23, Y+9	; 0x09
     b6a:	8a 81       	ldd	r24, Y+2	; 0x02
     b6c:	9b 81       	ldd	r25, Y+3	; 0x03
     b6e:	8a 01       	movw	r16, r20
     b70:	4e 85       	ldd	r20, Y+14	; 0x0e
     b72:	0e 94 ce 08 	call	0x119c	; 0x119c <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     b76:	4c 85       	ldd	r20, Y+12	; 0x0c
     b78:	5d 85       	ldd	r21, Y+13	; 0x0d
     b7a:	2e 81       	ldd	r18, Y+6	; 0x06
     b7c:	3f 81       	ldd	r19, Y+7	; 0x07
     b7e:	8c 81       	ldd	r24, Y+4	; 0x04
     b80:	9d 81       	ldd	r25, Y+5	; 0x05
     b82:	b9 01       	movw	r22, r18
     b84:	0e 94 c1 02 	call	0x582	; 0x582 <pxPortInitialiseStack>
     b88:	9c 01       	movw	r18, r24
     b8a:	8a 81       	ldd	r24, Y+2	; 0x02
     b8c:	9b 81       	ldd	r25, Y+3	; 0x03
     b8e:	fc 01       	movw	r30, r24
     b90:	31 83       	std	Z+1, r19	; 0x01
     b92:	20 83       	st	Z, r18
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
     b94:	8f 85       	ldd	r24, Y+15	; 0x0f
     b96:	98 89       	ldd	r25, Y+16	; 0x10
     b98:	00 97       	sbiw	r24, 0x00	; 0
     b9a:	39 f0       	breq	.+14     	; 0xbaa <xTaskGenericCreate+0xc2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     b9c:	8f 85       	ldd	r24, Y+15	; 0x0f
     b9e:	98 89       	ldd	r25, Y+16	; 0x10
     ba0:	2a 81       	ldd	r18, Y+2	; 0x02
     ba2:	3b 81       	ldd	r19, Y+3	; 0x03
     ba4:	fc 01       	movw	r30, r24
     ba6:	31 83       	std	Z+1, r19	; 0x01
     ba8:	20 83       	st	Z, r18
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
     baa:	0f b6       	in	r0, 0x3f	; 63
     bac:	f8 94       	cli
     bae:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     bb0:	80 91 61 0a 	lds	r24, 0x0A61
     bb4:	8f 5f       	subi	r24, 0xFF	; 255
     bb6:	80 93 61 0a 	sts	0x0A61, r24
			if( pxCurrentTCB == NULL )
     bba:	80 91 12 0a 	lds	r24, 0x0A12
     bbe:	90 91 13 0a 	lds	r25, 0x0A13
     bc2:	00 97       	sbiw	r24, 0x00	; 0
     bc4:	69 f4       	brne	.+26     	; 0xbe0 <xTaskGenericCreate+0xf8>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     bc6:	8a 81       	ldd	r24, Y+2	; 0x02
     bc8:	9b 81       	ldd	r25, Y+3	; 0x03
     bca:	90 93 13 0a 	sts	0x0A13, r25
     bce:	80 93 12 0a 	sts	0x0A12, r24

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     bd2:	80 91 61 0a 	lds	r24, 0x0A61
     bd6:	81 30       	cpi	r24, 0x01	; 1
     bd8:	b1 f4       	brne	.+44     	; 0xc06 <xTaskGenericCreate+0x11e>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
     bda:	0e 94 52 09 	call	0x12a4	; 0x12a4 <prvInitialiseTaskLists>
     bde:	13 c0       	rjmp	.+38     	; 0xc06 <xTaskGenericCreate+0x11e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     be0:	80 91 65 0a 	lds	r24, 0x0A65
     be4:	88 23       	and	r24, r24
     be6:	79 f4       	brne	.+30     	; 0xc06 <xTaskGenericCreate+0x11e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     be8:	80 91 12 0a 	lds	r24, 0x0A12
     bec:	90 91 13 0a 	lds	r25, 0x0A13
     bf0:	fc 01       	movw	r30, r24
     bf2:	96 89       	ldd	r25, Z+22	; 0x16
     bf4:	8e 85       	ldd	r24, Y+14	; 0x0e
     bf6:	89 17       	cp	r24, r25
     bf8:	30 f0       	brcs	.+12     	; 0xc06 <xTaskGenericCreate+0x11e>
					{
						pxCurrentTCB = pxNewTCB;
     bfa:	8a 81       	ldd	r24, Y+2	; 0x02
     bfc:	9b 81       	ldd	r25, Y+3	; 0x03
     bfe:	90 93 13 0a 	sts	0x0A13, r25
     c02:	80 93 12 0a 	sts	0x0A12, r24
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
     c06:	80 91 69 0a 	lds	r24, 0x0A69
     c0a:	8f 5f       	subi	r24, 0xFF	; 255
     c0c:	80 93 69 0a 	sts	0x0A69, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
     c10:	8a 81       	ldd	r24, Y+2	; 0x02
     c12:	9b 81       	ldd	r25, Y+3	; 0x03
     c14:	fc 01       	movw	r30, r24
     c16:	96 89       	ldd	r25, Z+22	; 0x16
     c18:	80 91 64 0a 	lds	r24, 0x0A64
     c1c:	89 17       	cp	r24, r25
     c1e:	30 f4       	brcc	.+12     	; 0xc2c <xTaskGenericCreate+0x144>
     c20:	8a 81       	ldd	r24, Y+2	; 0x02
     c22:	9b 81       	ldd	r25, Y+3	; 0x03
     c24:	fc 01       	movw	r30, r24
     c26:	86 89       	ldd	r24, Z+22	; 0x16
     c28:	80 93 64 0a 	sts	0x0A64, r24
     c2c:	8a 81       	ldd	r24, Y+2	; 0x02
     c2e:	9b 81       	ldd	r25, Y+3	; 0x03
     c30:	ac 01       	movw	r20, r24
     c32:	4e 5f       	subi	r20, 0xFE	; 254
     c34:	5f 4f       	sbci	r21, 0xFF	; 255
     c36:	8a 81       	ldd	r24, Y+2	; 0x02
     c38:	9b 81       	ldd	r25, Y+3	; 0x03
     c3a:	fc 01       	movw	r30, r24
     c3c:	86 89       	ldd	r24, Z+22	; 0x16
     c3e:	28 2f       	mov	r18, r24
     c40:	30 e0       	ldi	r19, 0x00	; 0
     c42:	c9 01       	movw	r24, r18
     c44:	88 0f       	add	r24, r24
     c46:	99 1f       	adc	r25, r25
     c48:	88 0f       	add	r24, r24
     c4a:	99 1f       	adc	r25, r25
     c4c:	88 0f       	add	r24, r24
     c4e:	99 1f       	adc	r25, r25
     c50:	82 0f       	add	r24, r18
     c52:	93 1f       	adc	r25, r19
     c54:	8c 5e       	subi	r24, 0xEC	; 236
     c56:	95 4f       	sbci	r25, 0xF5	; 245
     c58:	ba 01       	movw	r22, r20
     c5a:	0e 94 41 01 	call	0x282	; 0x282 <vListInsertEnd>

			xReturn = pdPASS;
     c5e:	81 e0       	ldi	r24, 0x01	; 1
     c60:	89 83       	std	Y+1, r24	; 0x01
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     c62:	0f 90       	pop	r0
     c64:	0f be       	out	0x3f, r0	; 63
     c66:	02 c0       	rjmp	.+4      	; 0xc6c <xTaskGenericCreate+0x184>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     c68:	8f ef       	ldi	r24, 0xFF	; 255
     c6a:	89 83       	std	Y+1, r24	; 0x01
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
     c6c:	89 81       	ldd	r24, Y+1	; 0x01
     c6e:	81 30       	cpi	r24, 0x01	; 1
     c70:	79 f4       	brne	.+30     	; 0xc90 <xTaskGenericCreate+0x1a8>
	{
		if( xSchedulerRunning != pdFALSE )
     c72:	80 91 65 0a 	lds	r24, 0x0A65
     c76:	88 23       	and	r24, r24
     c78:	59 f0       	breq	.+22     	; 0xc90 <xTaskGenericCreate+0x1a8>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     c7a:	80 91 12 0a 	lds	r24, 0x0A12
     c7e:	90 91 13 0a 	lds	r25, 0x0A13
     c82:	fc 01       	movw	r30, r24
     c84:	96 89       	ldd	r25, Z+22	; 0x16
     c86:	8e 85       	ldd	r24, Y+14	; 0x0e
     c88:	98 17       	cp	r25, r24
     c8a:	10 f4       	brcc	.+4      	; 0xc90 <xTaskGenericCreate+0x1a8>
			{
				taskYIELD_IF_USING_PREEMPTION();
     c8c:	0e 94 9f 04 	call	0x93e	; 0x93e <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
     c90:	89 81       	ldd	r24, Y+1	; 0x01
}
     c92:	64 96       	adiw	r28, 0x14	; 20
     c94:	0f b6       	in	r0, 0x3f	; 63
     c96:	f8 94       	cli
     c98:	de bf       	out	0x3e, r29	; 62
     c9a:	0f be       	out	0x3f, r0	; 63
     c9c:	cd bf       	out	0x3d, r28	; 61
     c9e:	df 91       	pop	r29
     ca0:	cf 91       	pop	r28
     ca2:	1f 91       	pop	r17
     ca4:	0f 91       	pop	r16
     ca6:	ff 90       	pop	r15
     ca8:	ef 90       	pop	r14
     caa:	df 90       	pop	r13
     cac:	cf 90       	pop	r12
     cae:	bf 90       	pop	r11
     cb0:	af 90       	pop	r10
     cb2:	08 95       	ret

00000cb4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     cb4:	cf 93       	push	r28
     cb6:	df 93       	push	r29
     cb8:	00 d0       	rcall	.+0      	; 0xcba <vTaskDelay+0x6>
     cba:	00 d0       	rcall	.+0      	; 0xcbc <vTaskDelay+0x8>
     cbc:	1f 92       	push	r1
     cbe:	cd b7       	in	r28, 0x3d	; 61
     cc0:	de b7       	in	r29, 0x3e	; 62
     cc2:	9d 83       	std	Y+5, r25	; 0x05
     cc4:	8c 83       	std	Y+4, r24	; 0x04
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
     cc6:	19 82       	std	Y+1, r1	; 0x01


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     cc8:	8c 81       	ldd	r24, Y+4	; 0x04
     cca:	9d 81       	ldd	r25, Y+5	; 0x05
     ccc:	00 97       	sbiw	r24, 0x00	; 0
     cce:	d1 f0       	breq	.+52     	; 0xd04 <vTaskDelay+0x50>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     cd0:	0e 94 c5 06 	call	0xd8a	; 0xd8a <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     cd4:	20 91 62 0a 	lds	r18, 0x0A62
     cd8:	30 91 63 0a 	lds	r19, 0x0A63
     cdc:	8c 81       	ldd	r24, Y+4	; 0x04
     cde:	9d 81       	ldd	r25, Y+5	; 0x05
     ce0:	82 0f       	add	r24, r18
     ce2:	93 1f       	adc	r25, r19
     ce4:	9b 83       	std	Y+3, r25	; 0x03
     ce6:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
     ce8:	80 91 12 0a 	lds	r24, 0x0A12
     cec:	90 91 13 0a 	lds	r25, 0x0A13
     cf0:	02 96       	adiw	r24, 0x02	; 2
     cf2:	0e 94 08 02 	call	0x410	; 0x410 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     cf6:	8a 81       	ldd	r24, Y+2	; 0x02
     cf8:	9b 81       	ldd	r25, Y+3	; 0x03
     cfa:	0e 94 cf 09 	call	0x139e	; 0x139e <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     cfe:	0e 94 d1 06 	call	0xda2	; 0xda2 <xTaskResumeAll>
     d02:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     d04:	89 81       	ldd	r24, Y+1	; 0x01
     d06:	88 23       	and	r24, r24
     d08:	11 f4       	brne	.+4      	; 0xd0e <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
     d0a:	0e 94 9f 04 	call	0x93e	; 0x93e <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     d0e:	0f 90       	pop	r0
     d10:	0f 90       	pop	r0
     d12:	0f 90       	pop	r0
     d14:	0f 90       	pop	r0
     d16:	0f 90       	pop	r0
     d18:	df 91       	pop	r29
     d1a:	cf 91       	pop	r28
     d1c:	08 95       	ret

00000d1e <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     d1e:	af 92       	push	r10
     d20:	bf 92       	push	r11
     d22:	cf 92       	push	r12
     d24:	df 92       	push	r13
     d26:	ef 92       	push	r14
     d28:	ff 92       	push	r15
     d2a:	0f 93       	push	r16
     d2c:	cf 93       	push	r28
     d2e:	df 93       	push	r29
     d30:	1f 92       	push	r1
     d32:	cd b7       	in	r28, 0x3d	; 61
     d34:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
     d36:	a1 2c       	mov	r10, r1
     d38:	b1 2c       	mov	r11, r1
     d3a:	c1 2c       	mov	r12, r1
     d3c:	d1 2c       	mov	r13, r1
     d3e:	e1 2c       	mov	r14, r1
     d40:	f1 2c       	mov	r15, r1
     d42:	00 e0       	ldi	r16, 0x00	; 0
     d44:	20 e0       	ldi	r18, 0x00	; 0
     d46:	30 e0       	ldi	r19, 0x00	; 0
     d48:	45 e5       	ldi	r20, 0x55	; 85
     d4a:	50 e0       	ldi	r21, 0x00	; 0
     d4c:	69 e0       	ldi	r22, 0x09	; 9
     d4e:	72 e0       	ldi	r23, 0x02	; 2
     d50:	8c eb       	ldi	r24, 0xBC	; 188
     d52:	98 e0       	ldi	r25, 0x08	; 8
     d54:	0e 94 74 05 	call	0xae8	; 0xae8 <xTaskGenericCreate>
     d58:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     d5a:	89 81       	ldd	r24, Y+1	; 0x01
     d5c:	81 30       	cpi	r24, 0x01	; 1
     d5e:	51 f4       	brne	.+20     	; 0xd74 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     d60:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
     d62:	81 e0       	ldi	r24, 0x01	; 1
     d64:	80 93 65 0a 	sts	0x0A65, r24
		xTickCount = ( TickType_t ) 0U;
     d68:	10 92 63 0a 	sts	0x0A63, r1
     d6c:	10 92 62 0a 	sts	0x0A62, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     d70:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
     d74:	0f 90       	pop	r0
     d76:	df 91       	pop	r29
     d78:	cf 91       	pop	r28
     d7a:	0f 91       	pop	r16
     d7c:	ff 90       	pop	r15
     d7e:	ef 90       	pop	r14
     d80:	df 90       	pop	r13
     d82:	cf 90       	pop	r12
     d84:	bf 90       	pop	r11
     d86:	af 90       	pop	r10
     d88:	08 95       	ret

00000d8a <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
     d8a:	cf 93       	push	r28
     d8c:	df 93       	push	r29
     d8e:	cd b7       	in	r28, 0x3d	; 61
     d90:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     d92:	80 91 6a 0a 	lds	r24, 0x0A6A
     d96:	8f 5f       	subi	r24, 0xFF	; 255
     d98:	80 93 6a 0a 	sts	0x0A6A, r24
}
     d9c:	df 91       	pop	r29
     d9e:	cf 91       	pop	r28
     da0:	08 95       	ret

00000da2 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     da2:	cf 93       	push	r28
     da4:	df 93       	push	r29
     da6:	00 d0       	rcall	.+0      	; 0xda8 <xTaskResumeAll+0x6>
     da8:	1f 92       	push	r1
     daa:	cd b7       	in	r28, 0x3d	; 61
     dac:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
     dae:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     db0:	0f b6       	in	r0, 0x3f	; 63
     db2:	f8 94       	cli
     db4:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     db6:	80 91 6a 0a 	lds	r24, 0x0A6A
     dba:	81 50       	subi	r24, 0x01	; 1
     dbc:	80 93 6a 0a 	sts	0x0A6A, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     dc0:	80 91 6a 0a 	lds	r24, 0x0A6A
     dc4:	88 23       	and	r24, r24
     dc6:	09 f0       	breq	.+2      	; 0xdca <xTaskResumeAll+0x28>
     dc8:	71 c0       	rjmp	.+226    	; 0xeac <xTaskResumeAll+0x10a>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     dca:	80 91 61 0a 	lds	r24, 0x0A61
     dce:	88 23       	and	r24, r24
     dd0:	09 f4       	brne	.+2      	; 0xdd4 <xTaskResumeAll+0x32>
     dd2:	6c c0       	rjmp	.+216    	; 0xeac <xTaskResumeAll+0x10a>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     dd4:	49 c0       	rjmp	.+146    	; 0xe68 <xTaskResumeAll+0xc6>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     dd6:	80 91 53 0a 	lds	r24, 0x0A53
     dda:	90 91 54 0a 	lds	r25, 0x0A54
     dde:	fc 01       	movw	r30, r24
     de0:	86 81       	ldd	r24, Z+6	; 0x06
     de2:	97 81       	ldd	r25, Z+7	; 0x07
     de4:	9b 83       	std	Y+3, r25	; 0x03
     de6:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     de8:	8a 81       	ldd	r24, Y+2	; 0x02
     dea:	9b 81       	ldd	r25, Y+3	; 0x03
     dec:	0c 96       	adiw	r24, 0x0c	; 12
     dee:	0e 94 08 02 	call	0x410	; 0x410 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     df2:	8a 81       	ldd	r24, Y+2	; 0x02
     df4:	9b 81       	ldd	r25, Y+3	; 0x03
     df6:	02 96       	adiw	r24, 0x02	; 2
     df8:	0e 94 08 02 	call	0x410	; 0x410 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     dfc:	8a 81       	ldd	r24, Y+2	; 0x02
     dfe:	9b 81       	ldd	r25, Y+3	; 0x03
     e00:	fc 01       	movw	r30, r24
     e02:	96 89       	ldd	r25, Z+22	; 0x16
     e04:	80 91 64 0a 	lds	r24, 0x0A64
     e08:	89 17       	cp	r24, r25
     e0a:	30 f4       	brcc	.+12     	; 0xe18 <xTaskResumeAll+0x76>
     e0c:	8a 81       	ldd	r24, Y+2	; 0x02
     e0e:	9b 81       	ldd	r25, Y+3	; 0x03
     e10:	fc 01       	movw	r30, r24
     e12:	86 89       	ldd	r24, Z+22	; 0x16
     e14:	80 93 64 0a 	sts	0x0A64, r24
     e18:	8a 81       	ldd	r24, Y+2	; 0x02
     e1a:	9b 81       	ldd	r25, Y+3	; 0x03
     e1c:	ac 01       	movw	r20, r24
     e1e:	4e 5f       	subi	r20, 0xFE	; 254
     e20:	5f 4f       	sbci	r21, 0xFF	; 255
     e22:	8a 81       	ldd	r24, Y+2	; 0x02
     e24:	9b 81       	ldd	r25, Y+3	; 0x03
     e26:	fc 01       	movw	r30, r24
     e28:	86 89       	ldd	r24, Z+22	; 0x16
     e2a:	28 2f       	mov	r18, r24
     e2c:	30 e0       	ldi	r19, 0x00	; 0
     e2e:	c9 01       	movw	r24, r18
     e30:	88 0f       	add	r24, r24
     e32:	99 1f       	adc	r25, r25
     e34:	88 0f       	add	r24, r24
     e36:	99 1f       	adc	r25, r25
     e38:	88 0f       	add	r24, r24
     e3a:	99 1f       	adc	r25, r25
     e3c:	82 0f       	add	r24, r18
     e3e:	93 1f       	adc	r25, r19
     e40:	8c 5e       	subi	r24, 0xEC	; 236
     e42:	95 4f       	sbci	r25, 0xF5	; 245
     e44:	ba 01       	movw	r22, r20
     e46:	0e 94 41 01 	call	0x282	; 0x282 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     e4a:	8a 81       	ldd	r24, Y+2	; 0x02
     e4c:	9b 81       	ldd	r25, Y+3	; 0x03
     e4e:	fc 01       	movw	r30, r24
     e50:	26 89       	ldd	r18, Z+22	; 0x16
     e52:	80 91 12 0a 	lds	r24, 0x0A12
     e56:	90 91 13 0a 	lds	r25, 0x0A13
     e5a:	fc 01       	movw	r30, r24
     e5c:	86 89       	ldd	r24, Z+22	; 0x16
     e5e:	28 17       	cp	r18, r24
     e60:	18 f0       	brcs	.+6      	; 0xe68 <xTaskResumeAll+0xc6>
					{
						xYieldPending = pdTRUE;
     e62:	81 e0       	ldi	r24, 0x01	; 1
     e64:	80 93 67 0a 	sts	0x0A67, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     e68:	80 91 4e 0a 	lds	r24, 0x0A4E
     e6c:	88 23       	and	r24, r24
     e6e:	09 f0       	breq	.+2      	; 0xe72 <xTaskResumeAll+0xd0>
     e70:	b2 cf       	rjmp	.-156    	; 0xdd6 <xTaskResumeAll+0x34>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
     e72:	80 91 66 0a 	lds	r24, 0x0A66
     e76:	88 23       	and	r24, r24
     e78:	89 f0       	breq	.+34     	; 0xe9c <xTaskResumeAll+0xfa>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     e7a:	0c c0       	rjmp	.+24     	; 0xe94 <xTaskResumeAll+0xf2>
					{
						if( xTaskIncrementTick() != pdFALSE )
     e7c:	0e 94 5f 07 	call	0xebe	; 0xebe <xTaskIncrementTick>
     e80:	88 23       	and	r24, r24
     e82:	19 f0       	breq	.+6      	; 0xe8a <xTaskResumeAll+0xe8>
						{
							xYieldPending = pdTRUE;
     e84:	81 e0       	ldi	r24, 0x01	; 1
     e86:	80 93 67 0a 	sts	0x0A67, r24
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
     e8a:	80 91 66 0a 	lds	r24, 0x0A66
     e8e:	81 50       	subi	r24, 0x01	; 1
     e90:	80 93 66 0a 	sts	0x0A66, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     e94:	80 91 66 0a 	lds	r24, 0x0A66
     e98:	88 23       	and	r24, r24
     e9a:	81 f7       	brne	.-32     	; 0xe7c <xTaskResumeAll+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
     e9c:	80 91 67 0a 	lds	r24, 0x0A67
     ea0:	81 30       	cpi	r24, 0x01	; 1
     ea2:	21 f4       	brne	.+8      	; 0xeac <xTaskResumeAll+0x10a>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     ea4:	81 e0       	ldi	r24, 0x01	; 1
     ea6:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     ea8:	0e 94 9f 04 	call	0x93e	; 0x93e <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     eac:	0f 90       	pop	r0
     eae:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
     eb0:	89 81       	ldd	r24, Y+1	; 0x01
}
     eb2:	0f 90       	pop	r0
     eb4:	0f 90       	pop	r0
     eb6:	0f 90       	pop	r0
     eb8:	df 91       	pop	r29
     eba:	cf 91       	pop	r28
     ebc:	08 95       	ret

00000ebe <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     ebe:	cf 93       	push	r28
     ec0:	df 93       	push	r29
     ec2:	cd b7       	in	r28, 0x3d	; 61
     ec4:	de b7       	in	r29, 0x3e	; 62
     ec6:	29 97       	sbiw	r28, 0x09	; 9
     ec8:	0f b6       	in	r0, 0x3f	; 63
     eca:	f8 94       	cli
     ecc:	de bf       	out	0x3e, r29	; 62
     ece:	0f be       	out	0x3f, r0	; 63
     ed0:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     ed2:	19 82       	std	Y+1, r1	; 0x01

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     ed4:	80 91 6a 0a 	lds	r24, 0x0A6A
     ed8:	88 23       	and	r24, r24
     eda:	09 f0       	breq	.+2      	; 0xede <xTaskIncrementTick+0x20>
     edc:	c9 c0       	rjmp	.+402    	; 0x1070 <xTaskIncrementTick+0x1b2>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
     ede:	80 91 62 0a 	lds	r24, 0x0A62
     ee2:	90 91 63 0a 	lds	r25, 0x0A63
     ee6:	01 96       	adiw	r24, 0x01	; 1
     ee8:	90 93 63 0a 	sts	0x0A63, r25
     eec:	80 93 62 0a 	sts	0x0A62, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     ef0:	80 91 62 0a 	lds	r24, 0x0A62
     ef4:	90 91 63 0a 	lds	r25, 0x0A63
     ef8:	9b 83       	std	Y+3, r25	; 0x03
     efa:	8a 83       	std	Y+2, r24	; 0x02

			if( xConstTickCount == ( TickType_t ) 0U )
     efc:	8a 81       	ldd	r24, Y+2	; 0x02
     efe:	9b 81       	ldd	r25, Y+3	; 0x03
     f00:	00 97       	sbiw	r24, 0x00	; 0
     f02:	d9 f4       	brne	.+54     	; 0xf3a <xTaskIncrementTick+0x7c>
			{
				taskSWITCH_DELAYED_LISTS();
     f04:	80 91 4a 0a 	lds	r24, 0x0A4A
     f08:	90 91 4b 0a 	lds	r25, 0x0A4B
     f0c:	9d 83       	std	Y+5, r25	; 0x05
     f0e:	8c 83       	std	Y+4, r24	; 0x04
     f10:	80 91 4c 0a 	lds	r24, 0x0A4C
     f14:	90 91 4d 0a 	lds	r25, 0x0A4D
     f18:	90 93 4b 0a 	sts	0x0A4B, r25
     f1c:	80 93 4a 0a 	sts	0x0A4A, r24
     f20:	8c 81       	ldd	r24, Y+4	; 0x04
     f22:	9d 81       	ldd	r25, Y+5	; 0x05
     f24:	90 93 4d 0a 	sts	0x0A4D, r25
     f28:	80 93 4c 0a 	sts	0x0A4C, r24
     f2c:	80 91 68 0a 	lds	r24, 0x0A68
     f30:	8f 5f       	subi	r24, 0xFF	; 255
     f32:	80 93 68 0a 	sts	0x0A68, r24
     f36:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
     f3a:	80 91 02 02 	lds	r24, 0x0202
     f3e:	90 91 03 02 	lds	r25, 0x0203
     f42:	2a 81       	ldd	r18, Y+2	; 0x02
     f44:	3b 81       	ldd	r19, Y+3	; 0x03
     f46:	28 17       	cp	r18, r24
     f48:	39 07       	cpc	r19, r25
     f4a:	08 f4       	brcc	.+2      	; 0xf4e <xTaskIncrementTick+0x90>
     f4c:	77 c0       	rjmp	.+238    	; 0x103c <xTaskIncrementTick+0x17e>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     f4e:	80 91 4a 0a 	lds	r24, 0x0A4A
     f52:	90 91 4b 0a 	lds	r25, 0x0A4B
     f56:	fc 01       	movw	r30, r24
     f58:	80 81       	ld	r24, Z
     f5a:	88 23       	and	r24, r24
     f5c:	39 f4       	brne	.+14     	; 0xf6c <xTaskIncrementTick+0xae>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
     f5e:	8f ef       	ldi	r24, 0xFF	; 255
     f60:	9f ef       	ldi	r25, 0xFF	; 255
     f62:	90 93 03 02 	sts	0x0203, r25
     f66:	80 93 02 02 	sts	0x0202, r24
						break;
     f6a:	68 c0       	rjmp	.+208    	; 0x103c <xTaskIncrementTick+0x17e>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     f6c:	80 91 4a 0a 	lds	r24, 0x0A4A
     f70:	90 91 4b 0a 	lds	r25, 0x0A4B
     f74:	fc 01       	movw	r30, r24
     f76:	85 81       	ldd	r24, Z+5	; 0x05
     f78:	96 81       	ldd	r25, Z+6	; 0x06
     f7a:	fc 01       	movw	r30, r24
     f7c:	86 81       	ldd	r24, Z+6	; 0x06
     f7e:	97 81       	ldd	r25, Z+7	; 0x07
     f80:	9f 83       	std	Y+7, r25	; 0x07
     f82:	8e 83       	std	Y+6, r24	; 0x06
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     f84:	8e 81       	ldd	r24, Y+6	; 0x06
     f86:	9f 81       	ldd	r25, Y+7	; 0x07
     f88:	fc 01       	movw	r30, r24
     f8a:	82 81       	ldd	r24, Z+2	; 0x02
     f8c:	93 81       	ldd	r25, Z+3	; 0x03
     f8e:	99 87       	std	Y+9, r25	; 0x09
     f90:	88 87       	std	Y+8, r24	; 0x08

						if( xConstTickCount < xItemValue )
     f92:	2a 81       	ldd	r18, Y+2	; 0x02
     f94:	3b 81       	ldd	r19, Y+3	; 0x03
     f96:	88 85       	ldd	r24, Y+8	; 0x08
     f98:	99 85       	ldd	r25, Y+9	; 0x09
     f9a:	28 17       	cp	r18, r24
     f9c:	39 07       	cpc	r19, r25
     f9e:	38 f4       	brcc	.+14     	; 0xfae <xTaskIncrementTick+0xf0>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
     fa0:	88 85       	ldd	r24, Y+8	; 0x08
     fa2:	99 85       	ldd	r25, Y+9	; 0x09
     fa4:	90 93 03 02 	sts	0x0203, r25
     fa8:	80 93 02 02 	sts	0x0202, r24
							break;
     fac:	47 c0       	rjmp	.+142    	; 0x103c <xTaskIncrementTick+0x17e>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     fae:	8e 81       	ldd	r24, Y+6	; 0x06
     fb0:	9f 81       	ldd	r25, Y+7	; 0x07
     fb2:	02 96       	adiw	r24, 0x02	; 2
     fb4:	0e 94 08 02 	call	0x410	; 0x410 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     fb8:	8e 81       	ldd	r24, Y+6	; 0x06
     fba:	9f 81       	ldd	r25, Y+7	; 0x07
     fbc:	fc 01       	movw	r30, r24
     fbe:	84 89       	ldd	r24, Z+20	; 0x14
     fc0:	95 89       	ldd	r25, Z+21	; 0x15
     fc2:	00 97       	sbiw	r24, 0x00	; 0
     fc4:	29 f0       	breq	.+10     	; 0xfd0 <xTaskIncrementTick+0x112>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     fc6:	8e 81       	ldd	r24, Y+6	; 0x06
     fc8:	9f 81       	ldd	r25, Y+7	; 0x07
     fca:	0c 96       	adiw	r24, 0x0c	; 12
     fcc:	0e 94 08 02 	call	0x410	; 0x410 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
     fd0:	8e 81       	ldd	r24, Y+6	; 0x06
     fd2:	9f 81       	ldd	r25, Y+7	; 0x07
     fd4:	fc 01       	movw	r30, r24
     fd6:	96 89       	ldd	r25, Z+22	; 0x16
     fd8:	80 91 64 0a 	lds	r24, 0x0A64
     fdc:	89 17       	cp	r24, r25
     fde:	30 f4       	brcc	.+12     	; 0xfec <xTaskIncrementTick+0x12e>
     fe0:	8e 81       	ldd	r24, Y+6	; 0x06
     fe2:	9f 81       	ldd	r25, Y+7	; 0x07
     fe4:	fc 01       	movw	r30, r24
     fe6:	86 89       	ldd	r24, Z+22	; 0x16
     fe8:	80 93 64 0a 	sts	0x0A64, r24
     fec:	8e 81       	ldd	r24, Y+6	; 0x06
     fee:	9f 81       	ldd	r25, Y+7	; 0x07
     ff0:	ac 01       	movw	r20, r24
     ff2:	4e 5f       	subi	r20, 0xFE	; 254
     ff4:	5f 4f       	sbci	r21, 0xFF	; 255
     ff6:	8e 81       	ldd	r24, Y+6	; 0x06
     ff8:	9f 81       	ldd	r25, Y+7	; 0x07
     ffa:	fc 01       	movw	r30, r24
     ffc:	86 89       	ldd	r24, Z+22	; 0x16
     ffe:	28 2f       	mov	r18, r24
    1000:	30 e0       	ldi	r19, 0x00	; 0
    1002:	c9 01       	movw	r24, r18
    1004:	88 0f       	add	r24, r24
    1006:	99 1f       	adc	r25, r25
    1008:	88 0f       	add	r24, r24
    100a:	99 1f       	adc	r25, r25
    100c:	88 0f       	add	r24, r24
    100e:	99 1f       	adc	r25, r25
    1010:	82 0f       	add	r24, r18
    1012:	93 1f       	adc	r25, r19
    1014:	8c 5e       	subi	r24, 0xEC	; 236
    1016:	95 4f       	sbci	r25, 0xF5	; 245
    1018:	ba 01       	movw	r22, r20
    101a:	0e 94 41 01 	call	0x282	; 0x282 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    101e:	8e 81       	ldd	r24, Y+6	; 0x06
    1020:	9f 81       	ldd	r25, Y+7	; 0x07
    1022:	fc 01       	movw	r30, r24
    1024:	26 89       	ldd	r18, Z+22	; 0x16
    1026:	80 91 12 0a 	lds	r24, 0x0A12
    102a:	90 91 13 0a 	lds	r25, 0x0A13
    102e:	fc 01       	movw	r30, r24
    1030:	86 89       	ldd	r24, Z+22	; 0x16
    1032:	28 17       	cp	r18, r24
    1034:	10 f0       	brcs	.+4      	; 0x103a <xTaskIncrementTick+0x17c>
							{
								xSwitchRequired = pdTRUE;
    1036:	81 e0       	ldi	r24, 0x01	; 1
    1038:	89 83       	std	Y+1, r24	; 0x01
								mtCOVERAGE_TEST_MARKER();
							}
						}
						#endif /* configUSE_PREEMPTION */
					}
				}
    103a:	89 cf       	rjmp	.-238    	; 0xf4e <xTaskIncrementTick+0x90>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    103c:	80 91 12 0a 	lds	r24, 0x0A12
    1040:	90 91 13 0a 	lds	r25, 0x0A13
    1044:	fc 01       	movw	r30, r24
    1046:	86 89       	ldd	r24, Z+22	; 0x16
    1048:	28 2f       	mov	r18, r24
    104a:	30 e0       	ldi	r19, 0x00	; 0
    104c:	c9 01       	movw	r24, r18
    104e:	88 0f       	add	r24, r24
    1050:	99 1f       	adc	r25, r25
    1052:	88 0f       	add	r24, r24
    1054:	99 1f       	adc	r25, r25
    1056:	88 0f       	add	r24, r24
    1058:	99 1f       	adc	r25, r25
    105a:	82 0f       	add	r24, r18
    105c:	93 1f       	adc	r25, r19
    105e:	8c 5e       	subi	r24, 0xEC	; 236
    1060:	95 4f       	sbci	r25, 0xF5	; 245
    1062:	fc 01       	movw	r30, r24
    1064:	80 81       	ld	r24, Z
    1066:	82 30       	cpi	r24, 0x02	; 2
    1068:	40 f0       	brcs	.+16     	; 0x107a <xTaskIncrementTick+0x1bc>
			{
				xSwitchRequired = pdTRUE;
    106a:	81 e0       	ldi	r24, 0x01	; 1
    106c:	89 83       	std	Y+1, r24	; 0x01
    106e:	05 c0       	rjmp	.+10     	; 0x107a <xTaskIncrementTick+0x1bc>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    1070:	80 91 66 0a 	lds	r24, 0x0A66
    1074:	8f 5f       	subi	r24, 0xFF	; 255
    1076:	80 93 66 0a 	sts	0x0A66, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    107a:	80 91 67 0a 	lds	r24, 0x0A67
    107e:	88 23       	and	r24, r24
    1080:	11 f0       	breq	.+4      	; 0x1086 <xTaskIncrementTick+0x1c8>
		{
			xSwitchRequired = pdTRUE;
    1082:	81 e0       	ldi	r24, 0x01	; 1
    1084:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    1086:	89 81       	ldd	r24, Y+1	; 0x01
}
    1088:	29 96       	adiw	r28, 0x09	; 9
    108a:	0f b6       	in	r0, 0x3f	; 63
    108c:	f8 94       	cli
    108e:	de bf       	out	0x3e, r29	; 62
    1090:	0f be       	out	0x3f, r0	; 63
    1092:	cd bf       	out	0x3d, r28	; 61
    1094:	df 91       	pop	r29
    1096:	cf 91       	pop	r28
    1098:	08 95       	ret

0000109a <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    109a:	cf 93       	push	r28
    109c:	df 93       	push	r29
    109e:	00 d0       	rcall	.+0      	; 0x10a0 <vTaskSwitchContext+0x6>
    10a0:	cd b7       	in	r28, 0x3d	; 61
    10a2:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    10a4:	80 91 6a 0a 	lds	r24, 0x0A6A
    10a8:	88 23       	and	r24, r24
    10aa:	21 f0       	breq	.+8      	; 0x10b4 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    10ac:	81 e0       	ldi	r24, 0x01	; 1
    10ae:	80 93 67 0a 	sts	0x0A67, r24
    10b2:	5d c0       	rjmp	.+186    	; 0x116e <vTaskSwitchContext+0xd4>
	}
	else
	{
		xYieldPending = pdFALSE;
    10b4:	10 92 67 0a 	sts	0x0A67, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    10b8:	05 c0       	rjmp	.+10     	; 0x10c4 <vTaskSwitchContext+0x2a>
    10ba:	80 91 64 0a 	lds	r24, 0x0A64
    10be:	81 50       	subi	r24, 0x01	; 1
    10c0:	80 93 64 0a 	sts	0x0A64, r24
    10c4:	80 91 64 0a 	lds	r24, 0x0A64
    10c8:	28 2f       	mov	r18, r24
    10ca:	30 e0       	ldi	r19, 0x00	; 0
    10cc:	c9 01       	movw	r24, r18
    10ce:	88 0f       	add	r24, r24
    10d0:	99 1f       	adc	r25, r25
    10d2:	88 0f       	add	r24, r24
    10d4:	99 1f       	adc	r25, r25
    10d6:	88 0f       	add	r24, r24
    10d8:	99 1f       	adc	r25, r25
    10da:	82 0f       	add	r24, r18
    10dc:	93 1f       	adc	r25, r19
    10de:	8c 5e       	subi	r24, 0xEC	; 236
    10e0:	95 4f       	sbci	r25, 0xF5	; 245
    10e2:	fc 01       	movw	r30, r24
    10e4:	80 81       	ld	r24, Z
    10e6:	88 23       	and	r24, r24
    10e8:	41 f3       	breq	.-48     	; 0x10ba <vTaskSwitchContext+0x20>
    10ea:	80 91 64 0a 	lds	r24, 0x0A64
    10ee:	28 2f       	mov	r18, r24
    10f0:	30 e0       	ldi	r19, 0x00	; 0
    10f2:	c9 01       	movw	r24, r18
    10f4:	88 0f       	add	r24, r24
    10f6:	99 1f       	adc	r25, r25
    10f8:	88 0f       	add	r24, r24
    10fa:	99 1f       	adc	r25, r25
    10fc:	88 0f       	add	r24, r24
    10fe:	99 1f       	adc	r25, r25
    1100:	82 0f       	add	r24, r18
    1102:	93 1f       	adc	r25, r19
    1104:	8c 5e       	subi	r24, 0xEC	; 236
    1106:	95 4f       	sbci	r25, 0xF5	; 245
    1108:	9a 83       	std	Y+2, r25	; 0x02
    110a:	89 83       	std	Y+1, r24	; 0x01
    110c:	89 81       	ldd	r24, Y+1	; 0x01
    110e:	9a 81       	ldd	r25, Y+2	; 0x02
    1110:	fc 01       	movw	r30, r24
    1112:	81 81       	ldd	r24, Z+1	; 0x01
    1114:	92 81       	ldd	r25, Z+2	; 0x02
    1116:	fc 01       	movw	r30, r24
    1118:	22 81       	ldd	r18, Z+2	; 0x02
    111a:	33 81       	ldd	r19, Z+3	; 0x03
    111c:	89 81       	ldd	r24, Y+1	; 0x01
    111e:	9a 81       	ldd	r25, Y+2	; 0x02
    1120:	fc 01       	movw	r30, r24
    1122:	32 83       	std	Z+2, r19	; 0x02
    1124:	21 83       	std	Z+1, r18	; 0x01
    1126:	89 81       	ldd	r24, Y+1	; 0x01
    1128:	9a 81       	ldd	r25, Y+2	; 0x02
    112a:	fc 01       	movw	r30, r24
    112c:	21 81       	ldd	r18, Z+1	; 0x01
    112e:	32 81       	ldd	r19, Z+2	; 0x02
    1130:	89 81       	ldd	r24, Y+1	; 0x01
    1132:	9a 81       	ldd	r25, Y+2	; 0x02
    1134:	03 96       	adiw	r24, 0x03	; 3
    1136:	28 17       	cp	r18, r24
    1138:	39 07       	cpc	r19, r25
    113a:	69 f4       	brne	.+26     	; 0x1156 <vTaskSwitchContext+0xbc>
    113c:	89 81       	ldd	r24, Y+1	; 0x01
    113e:	9a 81       	ldd	r25, Y+2	; 0x02
    1140:	fc 01       	movw	r30, r24
    1142:	81 81       	ldd	r24, Z+1	; 0x01
    1144:	92 81       	ldd	r25, Z+2	; 0x02
    1146:	fc 01       	movw	r30, r24
    1148:	22 81       	ldd	r18, Z+2	; 0x02
    114a:	33 81       	ldd	r19, Z+3	; 0x03
    114c:	89 81       	ldd	r24, Y+1	; 0x01
    114e:	9a 81       	ldd	r25, Y+2	; 0x02
    1150:	fc 01       	movw	r30, r24
    1152:	32 83       	std	Z+2, r19	; 0x02
    1154:	21 83       	std	Z+1, r18	; 0x01
    1156:	89 81       	ldd	r24, Y+1	; 0x01
    1158:	9a 81       	ldd	r25, Y+2	; 0x02
    115a:	fc 01       	movw	r30, r24
    115c:	81 81       	ldd	r24, Z+1	; 0x01
    115e:	92 81       	ldd	r25, Z+2	; 0x02
    1160:	fc 01       	movw	r30, r24
    1162:	86 81       	ldd	r24, Z+6	; 0x06
    1164:	97 81       	ldd	r25, Z+7	; 0x07
    1166:	90 93 13 0a 	sts	0x0A13, r25
    116a:	80 93 12 0a 	sts	0x0A12, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    116e:	0f 90       	pop	r0
    1170:	0f 90       	pop	r0
    1172:	df 91       	pop	r29
    1174:	cf 91       	pop	r28
    1176:	08 95       	ret

00001178 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    1178:	cf 93       	push	r28
    117a:	df 93       	push	r29
    117c:	00 d0       	rcall	.+0      	; 0x117e <prvIdleTask+0x6>
    117e:	cd b7       	in	r28, 0x3d	; 61
    1180:	de b7       	in	r29, 0x3e	; 62
    1182:	9a 83       	std	Y+2, r25	; 0x02
    1184:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    1186:	0e 94 8f 09 	call	0x131e	; 0x131e <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    118a:	80 91 14 0a 	lds	r24, 0x0A14
    118e:	82 30       	cpi	r24, 0x02	; 2
    1190:	10 f0       	brcs	.+4      	; 0x1196 <prvIdleTask+0x1e>
			{
				taskYIELD();
    1192:	0e 94 9f 04 	call	0x93e	; 0x93e <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
    1196:	0e 94 a7 00 	call	0x14e	; 0x14e <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    119a:	f5 cf       	rjmp	.-22     	; 0x1186 <prvIdleTask+0xe>

0000119c <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    119c:	0f 93       	push	r16
    119e:	1f 93       	push	r17
    11a0:	cf 93       	push	r28
    11a2:	df 93       	push	r29
    11a4:	cd b7       	in	r28, 0x3d	; 61
    11a6:	de b7       	in	r29, 0x3e	; 62
    11a8:	2a 97       	sbiw	r28, 0x0a	; 10
    11aa:	0f b6       	in	r0, 0x3f	; 63
    11ac:	f8 94       	cli
    11ae:	de bf       	out	0x3e, r29	; 62
    11b0:	0f be       	out	0x3f, r0	; 63
    11b2:	cd bf       	out	0x3d, r28	; 61
    11b4:	9b 83       	std	Y+3, r25	; 0x03
    11b6:	8a 83       	std	Y+2, r24	; 0x02
    11b8:	7d 83       	std	Y+5, r23	; 0x05
    11ba:	6c 83       	std	Y+4, r22	; 0x04
    11bc:	4e 83       	std	Y+6, r20	; 0x06
    11be:	38 87       	std	Y+8, r19	; 0x08
    11c0:	2f 83       	std	Y+7, r18	; 0x07
    11c2:	1a 87       	std	Y+10, r17	; 0x0a
    11c4:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    11c6:	19 82       	std	Y+1, r1	; 0x01
    11c8:	22 c0       	rjmp	.+68     	; 0x120e <prvInitialiseTCBVariables+0x72>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    11ca:	89 81       	ldd	r24, Y+1	; 0x01
    11cc:	88 2f       	mov	r24, r24
    11ce:	90 e0       	ldi	r25, 0x00	; 0
    11d0:	29 81       	ldd	r18, Y+1	; 0x01
    11d2:	22 2f       	mov	r18, r18
    11d4:	30 e0       	ldi	r19, 0x00	; 0
    11d6:	4c 81       	ldd	r20, Y+4	; 0x04
    11d8:	5d 81       	ldd	r21, Y+5	; 0x05
    11da:	24 0f       	add	r18, r20
    11dc:	35 1f       	adc	r19, r21
    11de:	f9 01       	movw	r30, r18
    11e0:	40 81       	ld	r20, Z
    11e2:	2a 81       	ldd	r18, Y+2	; 0x02
    11e4:	3b 81       	ldd	r19, Y+3	; 0x03
    11e6:	82 0f       	add	r24, r18
    11e8:	93 1f       	adc	r25, r19
    11ea:	49 96       	adiw	r24, 0x19	; 25
    11ec:	fc 01       	movw	r30, r24
    11ee:	40 83       	st	Z, r20

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    11f0:	89 81       	ldd	r24, Y+1	; 0x01
    11f2:	88 2f       	mov	r24, r24
    11f4:	90 e0       	ldi	r25, 0x00	; 0
    11f6:	2c 81       	ldd	r18, Y+4	; 0x04
    11f8:	3d 81       	ldd	r19, Y+5	; 0x05
    11fa:	82 0f       	add	r24, r18
    11fc:	93 1f       	adc	r25, r19
    11fe:	fc 01       	movw	r30, r24
    1200:	80 81       	ld	r24, Z
    1202:	88 23       	and	r24, r24
    1204:	09 f4       	brne	.+2      	; 0x1208 <prvInitialiseTCBVariables+0x6c>
		{
			break;
    1206:	06 c0       	rjmp	.+12     	; 0x1214 <prvInitialiseTCBVariables+0x78>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1208:	89 81       	ldd	r24, Y+1	; 0x01
    120a:	8f 5f       	subi	r24, 0xFF	; 255
    120c:	89 83       	std	Y+1, r24	; 0x01
    120e:	89 81       	ldd	r24, Y+1	; 0x01
    1210:	88 30       	cpi	r24, 0x08	; 8
    1212:	d8 f2       	brcs	.-74     	; 0x11ca <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    1214:	8a 81       	ldd	r24, Y+2	; 0x02
    1216:	9b 81       	ldd	r25, Y+3	; 0x03
    1218:	fc 01       	movw	r30, r24
    121a:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    121c:	8e 81       	ldd	r24, Y+6	; 0x06
    121e:	84 30       	cpi	r24, 0x04	; 4
    1220:	10 f0       	brcs	.+4      	; 0x1226 <prvInitialiseTCBVariables+0x8a>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    1222:	83 e0       	ldi	r24, 0x03	; 3
    1224:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    1226:	8a 81       	ldd	r24, Y+2	; 0x02
    1228:	9b 81       	ldd	r25, Y+3	; 0x03
    122a:	2e 81       	ldd	r18, Y+6	; 0x06
    122c:	fc 01       	movw	r30, r24
    122e:	26 8b       	std	Z+22, r18	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1230:	8a 81       	ldd	r24, Y+2	; 0x02
    1232:	9b 81       	ldd	r25, Y+3	; 0x03
    1234:	02 96       	adiw	r24, 0x02	; 2
    1236:	0e 94 30 01 	call	0x260	; 0x260 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    123a:	8a 81       	ldd	r24, Y+2	; 0x02
    123c:	9b 81       	ldd	r25, Y+3	; 0x03
    123e:	0c 96       	adiw	r24, 0x0c	; 12
    1240:	0e 94 30 01 	call	0x260	; 0x260 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1244:	8a 81       	ldd	r24, Y+2	; 0x02
    1246:	9b 81       	ldd	r25, Y+3	; 0x03
    1248:	2a 81       	ldd	r18, Y+2	; 0x02
    124a:	3b 81       	ldd	r19, Y+3	; 0x03
    124c:	fc 01       	movw	r30, r24
    124e:	31 87       	std	Z+9, r19	; 0x09
    1250:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1252:	8e 81       	ldd	r24, Y+6	; 0x06
    1254:	88 2f       	mov	r24, r24
    1256:	90 e0       	ldi	r25, 0x00	; 0
    1258:	24 e0       	ldi	r18, 0x04	; 4
    125a:	30 e0       	ldi	r19, 0x00	; 0
    125c:	28 1b       	sub	r18, r24
    125e:	39 0b       	sbc	r19, r25
    1260:	8a 81       	ldd	r24, Y+2	; 0x02
    1262:	9b 81       	ldd	r25, Y+3	; 0x03
    1264:	fc 01       	movw	r30, r24
    1266:	35 87       	std	Z+13, r19	; 0x0d
    1268:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    126a:	8a 81       	ldd	r24, Y+2	; 0x02
    126c:	9b 81       	ldd	r25, Y+3	; 0x03
    126e:	2a 81       	ldd	r18, Y+2	; 0x02
    1270:	3b 81       	ldd	r19, Y+3	; 0x03
    1272:	fc 01       	movw	r30, r24
    1274:	33 8b       	std	Z+19, r19	; 0x13
    1276:	22 8b       	std	Z+18, r18	; 0x12
	}
	#endif /* portUSING_MPU_WRAPPERS */

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
    1278:	8a 81       	ldd	r24, Y+2	; 0x02
    127a:	9b 81       	ldd	r25, Y+3	; 0x03
    127c:	fc 01       	movw	r30, r24
    127e:	11 a2       	std	Z+33, r1	; 0x21
    1280:	12 a2       	std	Z+34, r1	; 0x22
    1282:	13 a2       	std	Z+35, r1	; 0x23
    1284:	14 a2       	std	Z+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
    1286:	8a 81       	ldd	r24, Y+2	; 0x02
    1288:	9b 81       	ldd	r25, Y+3	; 0x03
    128a:	fc 01       	movw	r30, r24
    128c:	15 a2       	std	Z+37, r1	; 0x25
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    128e:	2a 96       	adiw	r28, 0x0a	; 10
    1290:	0f b6       	in	r0, 0x3f	; 63
    1292:	f8 94       	cli
    1294:	de bf       	out	0x3e, r29	; 62
    1296:	0f be       	out	0x3f, r0	; 63
    1298:	cd bf       	out	0x3d, r28	; 61
    129a:	df 91       	pop	r29
    129c:	cf 91       	pop	r28
    129e:	1f 91       	pop	r17
    12a0:	0f 91       	pop	r16
    12a2:	08 95       	ret

000012a4 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    12a4:	cf 93       	push	r28
    12a6:	df 93       	push	r29
    12a8:	1f 92       	push	r1
    12aa:	cd b7       	in	r28, 0x3d	; 61
    12ac:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    12ae:	19 82       	std	Y+1, r1	; 0x01
    12b0:	13 c0       	rjmp	.+38     	; 0x12d8 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    12b2:	89 81       	ldd	r24, Y+1	; 0x01
    12b4:	28 2f       	mov	r18, r24
    12b6:	30 e0       	ldi	r19, 0x00	; 0
    12b8:	c9 01       	movw	r24, r18
    12ba:	88 0f       	add	r24, r24
    12bc:	99 1f       	adc	r25, r25
    12be:	88 0f       	add	r24, r24
    12c0:	99 1f       	adc	r25, r25
    12c2:	88 0f       	add	r24, r24
    12c4:	99 1f       	adc	r25, r25
    12c6:	82 0f       	add	r24, r18
    12c8:	93 1f       	adc	r25, r19
    12ca:	8c 5e       	subi	r24, 0xEC	; 236
    12cc:	95 4f       	sbci	r25, 0xF5	; 245
    12ce:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    12d2:	89 81       	ldd	r24, Y+1	; 0x01
    12d4:	8f 5f       	subi	r24, 0xFF	; 255
    12d6:	89 83       	std	Y+1, r24	; 0x01
    12d8:	89 81       	ldd	r24, Y+1	; 0x01
    12da:	84 30       	cpi	r24, 0x04	; 4
    12dc:	50 f3       	brcs	.-44     	; 0x12b2 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    12de:	88 e3       	ldi	r24, 0x38	; 56
    12e0:	9a e0       	ldi	r25, 0x0A	; 10
    12e2:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    12e6:	81 e4       	ldi	r24, 0x41	; 65
    12e8:	9a e0       	ldi	r25, 0x0A	; 10
    12ea:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    12ee:	8e e4       	ldi	r24, 0x4E	; 78
    12f0:	9a e0       	ldi	r25, 0x0A	; 10
    12f2:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    12f6:	87 e5       	ldi	r24, 0x57	; 87
    12f8:	9a e0       	ldi	r25, 0x0A	; 10
    12fa:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    12fe:	88 e3       	ldi	r24, 0x38	; 56
    1300:	9a e0       	ldi	r25, 0x0A	; 10
    1302:	90 93 4b 0a 	sts	0x0A4B, r25
    1306:	80 93 4a 0a 	sts	0x0A4A, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    130a:	81 e4       	ldi	r24, 0x41	; 65
    130c:	9a e0       	ldi	r25, 0x0A	; 10
    130e:	90 93 4d 0a 	sts	0x0A4D, r25
    1312:	80 93 4c 0a 	sts	0x0A4C, r24
}
    1316:	0f 90       	pop	r0
    1318:	df 91       	pop	r29
    131a:	cf 91       	pop	r28
    131c:	08 95       	ret

0000131e <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    131e:	cf 93       	push	r28
    1320:	df 93       	push	r29
    1322:	00 d0       	rcall	.+0      	; 0x1324 <prvCheckTasksWaitingTermination+0x6>
    1324:	1f 92       	push	r1
    1326:	cd b7       	in	r28, 0x3d	; 61
    1328:	de b7       	in	r29, 0x3e	; 62
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    132a:	2f c0       	rjmp	.+94     	; 0x138a <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
    132c:	0e 94 c5 06 	call	0xd8a	; 0xd8a <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1330:	90 91 57 0a 	lds	r25, 0x0A57
    1334:	81 e0       	ldi	r24, 0x01	; 1
    1336:	99 23       	and	r25, r25
    1338:	09 f0       	breq	.+2      	; 0x133c <prvCheckTasksWaitingTermination+0x1e>
    133a:	80 e0       	ldi	r24, 0x00	; 0
    133c:	89 83       	std	Y+1, r24	; 0x01
			}
			( void ) xTaskResumeAll();
    133e:	0e 94 d1 06 	call	0xda2	; 0xda2 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1342:	89 81       	ldd	r24, Y+1	; 0x01
    1344:	88 23       	and	r24, r24
    1346:	09 f5       	brne	.+66     	; 0x138a <prvCheckTasksWaitingTermination+0x6c>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    1348:	0f b6       	in	r0, 0x3f	; 63
    134a:	f8 94       	cli
    134c:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    134e:	80 91 5c 0a 	lds	r24, 0x0A5C
    1352:	90 91 5d 0a 	lds	r25, 0x0A5D
    1356:	fc 01       	movw	r30, r24
    1358:	86 81       	ldd	r24, Z+6	; 0x06
    135a:	97 81       	ldd	r25, Z+7	; 0x07
    135c:	9b 83       	std	Y+3, r25	; 0x03
    135e:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1360:	8a 81       	ldd	r24, Y+2	; 0x02
    1362:	9b 81       	ldd	r25, Y+3	; 0x03
    1364:	02 96       	adiw	r24, 0x02	; 2
    1366:	0e 94 08 02 	call	0x410	; 0x410 <uxListRemove>
					--uxCurrentNumberOfTasks;
    136a:	80 91 61 0a 	lds	r24, 0x0A61
    136e:	81 50       	subi	r24, 0x01	; 1
    1370:	80 93 61 0a 	sts	0x0A61, r24
					--uxTasksDeleted;
    1374:	80 91 60 0a 	lds	r24, 0x0A60
    1378:	81 50       	subi	r24, 0x01	; 1
    137a:	80 93 60 0a 	sts	0x0A60, r24
				}
				taskEXIT_CRITICAL();
    137e:	0f 90       	pop	r0
    1380:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    1382:	8a 81       	ldd	r24, Y+2	; 0x02
    1384:	9b 81       	ldd	r25, Y+3	; 0x03
    1386:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    138a:	80 91 60 0a 	lds	r24, 0x0A60
    138e:	88 23       	and	r24, r24
    1390:	69 f6       	brne	.-102    	; 0x132c <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    1392:	0f 90       	pop	r0
    1394:	0f 90       	pop	r0
    1396:	0f 90       	pop	r0
    1398:	df 91       	pop	r29
    139a:	cf 91       	pop	r28
    139c:	08 95       	ret

0000139e <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    139e:	cf 93       	push	r28
    13a0:	df 93       	push	r29
    13a2:	00 d0       	rcall	.+0      	; 0x13a4 <prvAddCurrentTaskToDelayedList+0x6>
    13a4:	cd b7       	in	r28, 0x3d	; 61
    13a6:	de b7       	in	r29, 0x3e	; 62
    13a8:	9a 83       	std	Y+2, r25	; 0x02
    13aa:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    13ac:	80 91 12 0a 	lds	r24, 0x0A12
    13b0:	90 91 13 0a 	lds	r25, 0x0A13
    13b4:	29 81       	ldd	r18, Y+1	; 0x01
    13b6:	3a 81       	ldd	r19, Y+2	; 0x02
    13b8:	fc 01       	movw	r30, r24
    13ba:	33 83       	std	Z+3, r19	; 0x03
    13bc:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
    13be:	80 91 62 0a 	lds	r24, 0x0A62
    13c2:	90 91 63 0a 	lds	r25, 0x0A63
    13c6:	29 81       	ldd	r18, Y+1	; 0x01
    13c8:	3a 81       	ldd	r19, Y+2	; 0x02
    13ca:	28 17       	cp	r18, r24
    13cc:	39 07       	cpc	r19, r25
    13ce:	78 f4       	brcc	.+30     	; 0x13ee <prvAddCurrentTaskToDelayedList+0x50>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    13d0:	80 91 12 0a 	lds	r24, 0x0A12
    13d4:	90 91 13 0a 	lds	r25, 0x0A13
    13d8:	9c 01       	movw	r18, r24
    13da:	2e 5f       	subi	r18, 0xFE	; 254
    13dc:	3f 4f       	sbci	r19, 0xFF	; 255
    13de:	80 91 4c 0a 	lds	r24, 0x0A4C
    13e2:	90 91 4d 0a 	lds	r25, 0x0A4D
    13e6:	b9 01       	movw	r22, r18
    13e8:	0e 94 8f 01 	call	0x31e	; 0x31e <vListInsert>
    13ec:	1d c0       	rjmp	.+58     	; 0x1428 <prvAddCurrentTaskToDelayedList+0x8a>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    13ee:	80 91 12 0a 	lds	r24, 0x0A12
    13f2:	90 91 13 0a 	lds	r25, 0x0A13
    13f6:	9c 01       	movw	r18, r24
    13f8:	2e 5f       	subi	r18, 0xFE	; 254
    13fa:	3f 4f       	sbci	r19, 0xFF	; 255
    13fc:	80 91 4a 0a 	lds	r24, 0x0A4A
    1400:	90 91 4b 0a 	lds	r25, 0x0A4B
    1404:	b9 01       	movw	r22, r18
    1406:	0e 94 8f 01 	call	0x31e	; 0x31e <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    140a:	80 91 02 02 	lds	r24, 0x0202
    140e:	90 91 03 02 	lds	r25, 0x0203
    1412:	29 81       	ldd	r18, Y+1	; 0x01
    1414:	3a 81       	ldd	r19, Y+2	; 0x02
    1416:	28 17       	cp	r18, r24
    1418:	39 07       	cpc	r19, r25
    141a:	30 f4       	brcc	.+12     	; 0x1428 <prvAddCurrentTaskToDelayedList+0x8a>
		{
			xNextTaskUnblockTime = xTimeToWake;
    141c:	89 81       	ldd	r24, Y+1	; 0x01
    141e:	9a 81       	ldd	r25, Y+2	; 0x02
    1420:	90 93 03 02 	sts	0x0203, r25
    1424:	80 93 02 02 	sts	0x0202, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    1428:	0f 90       	pop	r0
    142a:	0f 90       	pop	r0
    142c:	df 91       	pop	r29
    142e:	cf 91       	pop	r28
    1430:	08 95       	ret

00001432 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    1432:	cf 93       	push	r28
    1434:	df 93       	push	r29
    1436:	cd b7       	in	r28, 0x3d	; 61
    1438:	de b7       	in	r29, 0x3e	; 62
    143a:	28 97       	sbiw	r28, 0x08	; 8
    143c:	0f b6       	in	r0, 0x3f	; 63
    143e:	f8 94       	cli
    1440:	de bf       	out	0x3e, r29	; 62
    1442:	0f be       	out	0x3f, r0	; 63
    1444:	cd bf       	out	0x3d, r28	; 61
    1446:	9e 83       	std	Y+6, r25	; 0x06
    1448:	8d 83       	std	Y+5, r24	; 0x05
    144a:	78 87       	std	Y+8, r23	; 0x08
    144c:	6f 83       	std	Y+7, r22	; 0x07
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    144e:	8f 81       	ldd	r24, Y+7	; 0x07
    1450:	98 85       	ldd	r25, Y+8	; 0x08
    1452:	00 97       	sbiw	r24, 0x00	; 0
    1454:	29 f4       	brne	.+10     	; 0x1460 <prvAllocateTCBAndStack+0x2e>
    1456:	8d 81       	ldd	r24, Y+5	; 0x05
    1458:	9e 81       	ldd	r25, Y+6	; 0x06
    145a:	0e 94 5f 02 	call	0x4be	; 0x4be <pvPortMalloc>
    145e:	02 c0       	rjmp	.+4      	; 0x1464 <prvAllocateTCBAndStack+0x32>
    1460:	8f 81       	ldd	r24, Y+7	; 0x07
    1462:	98 85       	ldd	r25, Y+8	; 0x08
    1464:	9c 83       	std	Y+4, r25	; 0x04
    1466:	8b 83       	std	Y+3, r24	; 0x03

		if( pxStack != NULL )
    1468:	8b 81       	ldd	r24, Y+3	; 0x03
    146a:	9c 81       	ldd	r25, Y+4	; 0x04
    146c:	00 97       	sbiw	r24, 0x00	; 0
    146e:	b9 f0       	breq	.+46     	; 0x149e <prvAllocateTCBAndStack+0x6c>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    1470:	86 e2       	ldi	r24, 0x26	; 38
    1472:	90 e0       	ldi	r25, 0x00	; 0
    1474:	0e 94 5f 02 	call	0x4be	; 0x4be <pvPortMalloc>
    1478:	9a 83       	std	Y+2, r25	; 0x02
    147a:	89 83       	std	Y+1, r24	; 0x01

			if( pxNewTCB != NULL )
    147c:	89 81       	ldd	r24, Y+1	; 0x01
    147e:	9a 81       	ldd	r25, Y+2	; 0x02
    1480:	00 97       	sbiw	r24, 0x00	; 0
    1482:	41 f0       	breq	.+16     	; 0x1494 <prvAllocateTCBAndStack+0x62>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
    1484:	89 81       	ldd	r24, Y+1	; 0x01
    1486:	9a 81       	ldd	r25, Y+2	; 0x02
    1488:	2b 81       	ldd	r18, Y+3	; 0x03
    148a:	3c 81       	ldd	r19, Y+4	; 0x04
    148c:	fc 01       	movw	r30, r24
    148e:	30 8f       	std	Z+24, r19	; 0x18
    1490:	27 8b       	std	Z+23, r18	; 0x17
    1492:	07 c0       	rjmp	.+14     	; 0x14a2 <prvAllocateTCBAndStack+0x70>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
    1494:	8b 81       	ldd	r24, Y+3	; 0x03
    1496:	9c 81       	ldd	r25, Y+4	; 0x04
    1498:	0e 94 b5 02 	call	0x56a	; 0x56a <vPortFree>
    149c:	02 c0       	rjmp	.+4      	; 0x14a2 <prvAllocateTCBAndStack+0x70>
			}
		}
		else
		{
			pxNewTCB = NULL;
    149e:	1a 82       	std	Y+2, r1	; 0x02
    14a0:	19 82       	std	Y+1, r1	; 0x01
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
		}
		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
	}

	return pxNewTCB;
    14a2:	89 81       	ldd	r24, Y+1	; 0x01
    14a4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    14a6:	28 96       	adiw	r28, 0x08	; 8
    14a8:	0f b6       	in	r0, 0x3f	; 63
    14aa:	f8 94       	cli
    14ac:	de bf       	out	0x3e, r29	; 62
    14ae:	0f be       	out	0x3f, r0	; 63
    14b0:	cd bf       	out	0x3d, r28	; 61
    14b2:	df 91       	pop	r29
    14b4:	cf 91       	pop	r28
    14b6:	08 95       	ret

000014b8 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    14b8:	cf 93       	push	r28
    14ba:	df 93       	push	r29
    14bc:	00 d0       	rcall	.+0      	; 0x14be <prvDeleteTCB+0x6>
    14be:	cd b7       	in	r28, 0x3d	; 61
    14c0:	de b7       	in	r29, 0x3e	; 62
    14c2:	9a 83       	std	Y+2, r25	; 0x02
    14c4:	89 83       	std	Y+1, r24	; 0x01
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
    14c6:	89 81       	ldd	r24, Y+1	; 0x01
    14c8:	9a 81       	ldd	r25, Y+2	; 0x02
    14ca:	fc 01       	movw	r30, r24
    14cc:	87 89       	ldd	r24, Z+23	; 0x17
    14ce:	90 8d       	ldd	r25, Z+24	; 0x18
    14d0:	0e 94 b5 02 	call	0x56a	; 0x56a <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
    14d4:	89 81       	ldd	r24, Y+1	; 0x01
    14d6:	9a 81       	ldd	r25, Y+2	; 0x02
    14d8:	0e 94 b5 02 	call	0x56a	; 0x56a <vPortFree>
	}
    14dc:	0f 90       	pop	r0
    14de:	0f 90       	pop	r0
    14e0:	df 91       	pop	r29
    14e2:	cf 91       	pop	r28
    14e4:	08 95       	ret

000014e6 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    14e6:	cf 93       	push	r28
    14e8:	df 93       	push	r29
    14ea:	00 d0       	rcall	.+0      	; 0x14ec <prvResetNextTaskUnblockTime+0x6>
    14ec:	cd b7       	in	r28, 0x3d	; 61
    14ee:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    14f0:	80 91 4a 0a 	lds	r24, 0x0A4A
    14f4:	90 91 4b 0a 	lds	r25, 0x0A4B
    14f8:	fc 01       	movw	r30, r24
    14fa:	80 81       	ld	r24, Z
    14fc:	88 23       	and	r24, r24
    14fe:	39 f4       	brne	.+14     	; 0x150e <prvResetNextTaskUnblockTime+0x28>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    1500:	8f ef       	ldi	r24, 0xFF	; 255
    1502:	9f ef       	ldi	r25, 0xFF	; 255
    1504:	90 93 03 02 	sts	0x0203, r25
    1508:	80 93 02 02 	sts	0x0202, r24
    150c:	15 c0       	rjmp	.+42     	; 0x1538 <prvResetNextTaskUnblockTime+0x52>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    150e:	80 91 4a 0a 	lds	r24, 0x0A4A
    1512:	90 91 4b 0a 	lds	r25, 0x0A4B
    1516:	fc 01       	movw	r30, r24
    1518:	85 81       	ldd	r24, Z+5	; 0x05
    151a:	96 81       	ldd	r25, Z+6	; 0x06
    151c:	fc 01       	movw	r30, r24
    151e:	86 81       	ldd	r24, Z+6	; 0x06
    1520:	97 81       	ldd	r25, Z+7	; 0x07
    1522:	9a 83       	std	Y+2, r25	; 0x02
    1524:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    1526:	89 81       	ldd	r24, Y+1	; 0x01
    1528:	9a 81       	ldd	r25, Y+2	; 0x02
    152a:	fc 01       	movw	r30, r24
    152c:	82 81       	ldd	r24, Z+2	; 0x02
    152e:	93 81       	ldd	r25, Z+3	; 0x03
    1530:	90 93 03 02 	sts	0x0203, r25
    1534:	80 93 02 02 	sts	0x0202, r24
	}
}
    1538:	0f 90       	pop	r0
    153a:	0f 90       	pop	r0
    153c:	df 91       	pop	r29
    153e:	cf 91       	pop	r28
    1540:	08 95       	ret

00001542 <_exit>:
    1542:	f8 94       	cli

00001544 <__stop_program>:
    1544:	ff cf       	rjmp	.-2      	; 0x1544 <__stop_program>

Disassembly of section .isr:

00001546 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	ISR( TIMER0_COMPA_vect, ISR_NAKED ISR_SECTION )
	{
		vPortYieldFromTick();
    1546:	0e 94 f8 04 	call	0x9f0	; 0x9f0 <vPortYieldFromTick>
		asm volatile ( "reti" );
    154a:	18 95       	reti
